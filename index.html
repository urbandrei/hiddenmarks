<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Table</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; }
        #lobby { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; background: #222; color: #fff; }
        #lobby button { cursor: pointer; }
        #lobby button:hover { filter: brightness(1.2); }
        #lobby button:disabled { opacity: 0.5; cursor: not-allowed; }
        .player-label { position: fixed; z-index: 100; pointer-events: none; background: rgba(0,0,0,0.6); color: #fff; padding: 0.3rem 0.5rem; }
        .player-label.bottom { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .player-label.top { top: 10px; left: 50%; transform: translateX(-50%); }
        .player-label.left { left: 10px; top: 50%; transform: translateY(-50%); }
        .player-label.right { right: 10px; top: 50%; transform: translateY(-50%); }
        #player-indicator, #action-counter { position: fixed; top: 10px; z-index: 100; background: rgba(0,0,0,0.5); color: #fff; padding: 0.3rem; }
        #player-indicator { left: 10px; }
        #action-counter { right: 10px; }
        .reaction-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .reaction-overlay.hidden { display: none; }
        .reaction-card-display {
            width: 200px;
            height: 280px;
            background: #333;
            border: 3px solid #fff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }
        .reaction-timer {
            font-size: 48px;
            color: #fff;
            font-family: monospace;
            margin-bottom: 20px;
        }
        .reaction-prompt {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .reaction-prompt p {
            color: #fff;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .reaction-buttons {
            display: flex;
            gap: 20px;
        }
        .reaction-buttons button {
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
        }
        .reaction-buttons .react-btn {
            background: #e74c3c;
            color: white;
        }
        .reaction-buttons .pass-btn {
            background: #7f8c8d;
            color: white;
        }
        .reaction-waiting {
            color: #aaa;
            font-style: italic;
        }
    </style>
</head>
<body>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        const CARD_WIDTH = 2.5;
        const CARD_HEIGHT = 3.5;
        const CARD_DEPTH = 0.02;

        // Card definitions from sprite sheet (10 cols x 6 rows)
        // Back indices: 54=red, 55=blue, 56=white, 57=mark
        // Card values by back color (mark cards have no value)
        const BACK_VALUES = { 54: 3, 55: 2, 56: 1 };
        const CARD_DEFS = [
            // White back (56)
            { index: 1, name: 'body swap', back: 56, count: 2, cost: 3, effect: 'swap any two player marks' },
            { index: 3, name: 'alter ego', back: 56, count: 2, cost: 2, effect: 'swap any player\'s mark\nwith the extra mark' },
            { index: 5, name: 'greed', back: 56, count: 2, cost: 0, effect: 'draw 2 cards' },
            { index: 7, name: 'tied up', back: 56, count: 2, cost: 3, effect: 'skip any player\'s next turn' },
            { index: 9, name: 'revenge', back: 56, count: 2, cost: 2, effect: 'REACTIVE:\nif someone tries to peek your mark\npeek at their mark, does not block' },
            { index: 11, name: 'insomnia', back: 56, count: 2, cost: 3, effect: 'do 3 more actions' },
            { index: 13, name: 'blind spot', back: 56, count: 2, cost: 2, effect: 'REACTIVE:\nblock a mark peek' },
            { index: 15, name: 'trade off', back: 56, count: 4, cost: 3, effect: 'swap any card from your hand\nwith a card from any hand/bank' },
            { index: 19, name: 'unmasked', back: 56, count: 4, cost: 3, effect: 'peek at another player\'s mark' },
            // Blue back (55)
            { index: 23, name: 'upheaval', back: 55, count: 2, cost: 5, effect: 'cut the draw pile' },
            { index: 25, name: 'arson', back: 55, count: 2, cost: 5, effect: 'discard all cards from any\nplayer\'s bank' },
            { index: 27, name: 'snub', back: 55, count: 4, cost: 5, effect: 'REACTIVE:\nprevent a nonlethal card effect' },
            { index: 31, name: 'red handed', back: 55, count: 2, cost: 10, effect: 'kill a player with 2+ red cards\nin their HAND' },
            { index: 33, name: 'counterfeit', back: 55, count: 3, cost: 10, effect: 'kill a player with 6+ cards\nin their BANK' },
            { index: 36, name: 'heavy hand', back: 55, count: 3, cost: 10, effect: 'kill a player with 6+ cards\nin their HAND' },
            // Red back (54)
            { index: 39, name: 'clubs bounty', back: 54, count: 1, cost: 0, effect: 'draw 3 cards. place this card face up\n\nWHILE FACE UP\nAnyone can discard this by paying 5\n\nOR AFTER 1 ROUND\nbounty open an [suit], see rules' },
            { index: 40, name: 'hearts bounty', back: 54, count: 1, cost: 0, effect: 'draw 3 cards. place this card face up\n\nWHILE FACE UP\nAnyone can discard this by paying 5\n\nOR AFTER 1 ROUND\nbounty open an [suit], see rules' },
            { index: 41, name: 'spades bounty', back: 54, count: 1, cost: 0, effect: 'draw 3 cards. place this card face up\n\nWHILE FACE UP\nAnyone can discard this by paying 5\n\nOR AFTER 1 ROUND\nbounty open an [suit], see rules' },
            { index: 42, name: 'diamonds bounty', back: 54, count: 1, cost: 0, effect: 'draw 3 cards. place this card face up\n\nWHILE FACE UP\nAnyone can discard this by paying 5\n\nOR AFTER 1 ROUND\nbounty open an [suit], see rules' },
            { index: 43, name: 'jokers bounty', back: 54, count: 1, cost: 0, effect: 'draw 3 cards. place this card face up\n\nWHILE FACE UP\nAnyone can discard this by paying 5\n\nOR AFTER 1 ROUND\nbounty open an [suit], see rules' },
            { index: 44, name: 'backfire', back: 54, count: 2, cost: 10, effect: 'kill a player with 5+ cards\nin their HAND' },
            { index: 46, name: 'bloodshot', back: 54, count: 1, cost: 10, effect: 'kill a player with any red card\nin their HAND' },
            { index: 47, name: 'gold digger', back: 54, count: 2, cost: 10, effect: 'kill a player with 5+ cards\nin their BANK' },
            // Mark back (57)
            { index: 49, name: 'hearts mark', back: 57, count: 1 },
            { index: 50, name: 'spades mark', back: 57, count: 1 },
            { index: 51, name: 'clubs mark', back: 57, count: 1 },
            { index: 52, name: 'diamonds mark', back: 57, count: 1 },
            { index: 53, name: 'jokers mark', back: 57, count: 1 },
        ];
        const SPRITE_COLS = 10;
        const SPRITE_ROWS = 6;

        const GAP = 0.5;
        const ZONE_LENGTH = 15;
        const MARK_WIDTH = CARD_WIDTH;
        const EFFECT_WIDTH = CARD_WIDTH * 1.5;
        const BANK_WIDTH = ZONE_LENGTH - MARK_WIDTH - EFFECT_WIDTH - GAP * 2;
        const zones = [
            // Player hands (edge zones - half off screen, stretched along edge)
            { id: 'p3-hand', type: 'hand', player: 3, x: 0, z: -10, rotation: 0, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-hand', type: 'hand', player: 1, x: 0, z: 10, rotation: 0, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-hand', type: 'hand', player: 4, x: -15, z: 0, rotation: Math.PI/2, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-hand', type: 'hand', player: 2, x: 15, z: 0, rotation: Math.PI/2, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Player banks (inner zones - overlapped by hands, stretched along edge)
            { id: 'p3-bank', type: 'bank', player: 3, x: 0, z: -10 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, rotation: 0, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-bank', type: 'bank', player: 1, x: 0, z: 10 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, rotation: 0, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-bank', type: 'bank', player: 4, x: -15 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, z: 0, rotation: Math.PI/2, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-bank', type: 'bank', player: 2, x: 15 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, z: 0, rotation: Math.PI/2, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Player mark zones (left of bank when facing center)
            { id: 'p3-mark', type: 'mark', player: 3, x: BANK_WIDTH/2 + GAP + MARK_WIDTH/2, z: -10 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, rotation: 0, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-mark', type: 'mark', player: 1, x: -BANK_WIDTH/2 - GAP - MARK_WIDTH/2, z: 10 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, rotation: 0, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-mark', type: 'mark', player: 4, x: -15 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, z: BANK_WIDTH/2 + GAP + MARK_WIDTH/2, rotation: Math.PI/2, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-mark', type: 'mark', player: 2, x: 15 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, z: -BANK_WIDTH/2 - GAP - MARK_WIDTH/2, rotation: Math.PI/2, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Player effect zones (right of bank when facing center)
            { id: 'p3-effect', type: 'effect', player: 3, x: -BANK_WIDTH/2 - GAP - EFFECT_WIDTH/2, z: -10 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, rotation: 0, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-effect', type: 'effect', player: 1, x: BANK_WIDTH/2 + GAP + EFFECT_WIDTH/2, z: 10 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, rotation: 0, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-effect', type: 'effect', player: 4, x: -15 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, z: -BANK_WIDTH/2 - GAP - EFFECT_WIDTH/2, rotation: Math.PI/2, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-effect', type: 'effect', player: 2, x: 15 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, z: BANK_WIDTH/2 + GAP + EFFECT_WIDTH/2, rotation: Math.PI/2, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Center piles
            { id: 'bounty', type: 'pile', player: null, x: -4 - ZONE_LENGTH/6 + CARD_WIDTH/2, z: 0, rotation: 0, width: ZONE_LENGTH/3, height: CARD_HEIGHT, spreadAxis: 'x', spreadDir: -1, cards: [] },
            { id: 'draw', type: 'pile', player: null, x: 0, z: 0, rotation: 0, width: CARD_WIDTH, height: CARD_HEIGHT, spreadAxis: null, cards: [] },
            { id: 'discard', type: 'pile', player: null, x: 3, z: 0, rotation: 0, width: CARD_WIDTH, height: CARD_HEIGHT, spreadAxis: null, cards: [] },
            { id: 'extra-mark', type: 'pile', player: null, x: 6, z: 0, rotation: 0, width: CARD_WIDTH, height: CARD_HEIGHT, spreadAxis: null, cards: [] },
        ];

        // Player lookup (index 1-4)
        const players = [
            null,
            { id: 1, hand: zones[1], bank: zones[5], mark: zones[9], effect: zones[13] },
            { id: 2, hand: zones[3], bank: zones[7], mark: zones[11], effect: zones[15] },
            { id: 3, hand: zones[0], bank: zones[4], mark: zones[8], effect: zones[12] },
            { id: 4, hand: zones[2], bank: zones[6], mark: zones[10], effect: zones[14] },
        ];

        // Center pile references
        const piles = {
            bounty: zones[16],
            draw: zones[17],
            discard: zones[18],
            extraMark: zones[19],
        };

        let scene, camera, renderer, raycaster, mouse;
        let cards = [];
        let draggedCard = null;
        let dragOffset = new THREE.Vector3();
        let dragStartPos = new THREE.Vector3();
        let tablePlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        let animatingCards = [];

        // Network state
        let peer = null;
        let isHost = false;
        let roomCode = null;
        let myPlayerNumber = null;
        let myPlayerId = null; // Generated fresh per session to allow multi-tab testing
        let myPlayerName = null;

        // Host-only state
        let connections = new Map();     // peerId -> DataConnection
        let playerSlots = new Map();     // playerId -> playerNumber
        let peerToPlayer = new Map();    // peerId -> playerId
        let playerNames = new Map();     // playerId -> name

        // Client-only state
        let hostConnection = null;

        // Shared state (for labels)
        let currentPlayerList = [];

        // Flag to ignore incoming state updates briefly after local actions
        let ignoreNextStateUpdate = false;

        // Turn state (synchronized across network)
        let turnState = {
            currentPlayerNum: 1,    // Player number whose turn it is (1-4)
            actionsRemaining: 3,    // Actions left this turn (0-3)
            gameStarted: false      // Whether the game has officially started
        };

        // Reaction state (synchronized across network)
        let reactionState = {
            active: false,
            card: null,              // Card being played (card object)
            cardIndex: null,         // Index in cards array for networking
            playerId: null,          // Player number who played it
            targetId: null,          // Target player number (if applicable)
            timeRemaining: 5000,     // Countdown in ms
            eligibleReactors: [],    // Player numbers who can react
            responses: {},           // playerId -> 'pass' | 'react'
            startTime: null,         // For countdown calculation
            effectType: null,        // 'peek', 'swap', 'skip', etc.
            isLethal: false          // Kill cards can't be blocked
        };

        // Mark knowledge state (host-tracked, broadcast to clients)
        let knownMarks = {}; // { playerId: Set<playerId> } - who knows whose marks

        // Player alive state
        let playerAlive = { 1: true, 2: true, 3: true, 4: true };

        // Turn tracking for bounty system
        let currentTurnNumber = 0;
        let bountyState = {}; // cardIndex -> { owner, turnPlayed, inBountyZone }

        // Upheaval state
        let upheavalState = {
            active: false,
            splitIndex: 0
        };

        // Targeting state
        let targetingState = {
            active: false,
            type: null,           // 'player', 'mark', 'card', 'zone'
            validTargets: [],     // IDs of valid targets
            callback: null,       // Function to call with selected target
            highlightMeshes: []   // Visual highlights to clean up
        };

        // Message types
        const MSG = {
            JOIN_REQUEST: 'join_request',
            JOIN_ACCEPTED: 'join_accepted',
            JOIN_REJECTED: 'join_rejected',
            PLAYER_LIST: 'player_list',
            STATE_UPDATE: 'state_update',
            STATE_BROADCAST: 'state_broadcast',
            REACTION_START: 'reaction_start',
            REACTION_RESPONSE: 'reaction_response',
            REACTION_RESOLVE: 'reaction_resolve',
            MARK_KNOWLEDGE_UPDATE: 'mark_knowledge_update',
            PLAYER_DEATH: 'player_death',
        };

        // === UTILITY FUNCTIONS ===

        // Update player labels around the table
        // Player positions: 1=bottom, 2=right, 3=top, 4=left
        function updatePlayerLabels() {
            // Remove existing labels
            document.querySelectorAll('.player-label').forEach(el => el.remove());

            if (!currentPlayerList.length) return;

            const positionClasses = ['bottom', 'right', 'top', 'left'];

            for (const player of currentPlayerList) {
                // Only show labels for connected players
                if (!player.connected) continue;

                const posClass = positionClasses[player.num - 1];
                const isYou = player.num === myPlayerNumber;

                const label = document.createElement('div');
                label.className = `player-label ${posClass}${isYou ? ' you' : ''}`;
                label.textContent = player.name || `Player ${player.num}`;
                document.body.appendChild(label);
            }

            // Also update turn indicators when game is started
            if (turnState.gameStarted) {
                updateTurnUI();
            }
        }

        function updateTurnUI() {
            // Update action counter display
            let counter = document.getElementById('action-counter');
            if (!counter && turnState.gameStarted) {
                counter = document.createElement('div');
                counter.id = 'action-counter';
                document.body.appendChild(counter);
            }

            if (counter) {
                // Show X's for remaining actions
                counter.textContent = 'X'.repeat(turnState.actionsRemaining);

                // Dim if not your turn
                if (turnState.currentPlayerNum === myPlayerNumber) {
                    counter.classList.remove('not-your-turn');
                } else {
                    counter.classList.add('not-your-turn');
                }
            }

            // Update player labels to highlight current turn
            document.querySelectorAll('.player-label').forEach(label => {
                label.classList.remove('current-turn');
            });

            // Find and highlight current turn player's label
            const positionClasses = ['bottom', 'right', 'top', 'left'];
            const currentPosClass = positionClasses[turnState.currentPlayerNum - 1];
            const currentLabel = document.querySelector(`.player-label.${currentPosClass}`);
            if (currentLabel) {
                currentLabel.classList.add('current-turn');
            }
        }

        function generateRoomCode() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        function getOrCreatePlayerId() {
            if (!myPlayerId) {
                myPlayerId = crypto.randomUUID();
            }
            return myPlayerId;
        }

        // === TURN MANAGEMENT ===

        function isMyTurn() {
            return turnState.gameStarted &&
                   turnState.currentPlayerNum === myPlayerNumber &&
                   turnState.actionsRemaining > 0;
        }

        function canPerformAction() {
            return isMyTurn();
        }

        function getNextConnectedPlayer(currentNum) {
            // Get list of connected and alive player numbers
            const activeNums = currentPlayerList
                .filter(p => p.connected && playerAlive[p.num])
                .map(p => p.num)
                .sort((a, b) => a - b);

            if (activeNums.length === 0) return currentNum;

            // Find next active player after currentNum
            const currentIndex = activeNums.indexOf(currentNum);
            const nextIndex = (currentIndex + 1) % activeNums.length;
            return activeNums[nextIndex];
        }

        function consumeAction() {
            if (!canPerformAction()) return false;

            turnState.actionsRemaining--;

            // Auto-pass turn when actions exhausted
            if (turnState.actionsRemaining <= 0) {
                advanceTurn();
            }

            updateTurnUI();
            return true;
        }

        function processEndOfTurn(playerNum) {
            const player = players[playerNum];
            if (!player) return;

            // Discard all cards in effect zone (insomnia, kill cards, etc.)
            while (player.effect.cards.length > 0) {
                const card = player.effect.cards.pop();
                piles.discard.cards.push(card);
            }
            layoutCardsInZone(player.effect);
            layoutCardsInZone(piles.discard);
        }

        function advanceTurn() {
            // Process end of turn effects for current player
            processEndOfTurn(turnState.currentPlayerNum);

            currentTurnNumber++;

            let nextPlayer = getNextConnectedPlayer(turnState.currentPlayerNum);

            // Keep advancing if player's turn is skipped (tied up)
            while (processStartOfTurn(nextPlayer)) {
                nextPlayer = getNextConnectedPlayer(nextPlayer);
            }

            // Process bounty progression for the new current player
            processBountyProgression(nextPlayer);

            turnState.currentPlayerNum = nextPlayer;
            turnState.actionsRemaining = 3;
            updateTurnUI();
        }

        function findCardZone(card) {
            for (const zone of zones) {
                if (zone.cards.includes(card)) {
                    return zone;
                }
            }
            return null;
        }

        // === ACTION EXECUTION ===

        function getCardCost(card) {
            const def = CARD_DEFS.find(d => d.name === card.userData.name);
            return def?.cost ?? 0;
        }

        function getCardValue(card) {
            const def = CARD_DEFS.find(d => d.name === card.userData.name);
            return def ? (BACK_VALUES[def.back] ?? 0) : 0;
        }

        function selectPayment(bankCards, cost) {
            if (cost <= 0) return [];

            const cardsWithValues = bankCards.map(card => ({
                card,
                value: getCardValue(card)
            }));

            const totalBankValue = cardsWithValues.reduce((sum, c) => sum + c.value, 0);
            if (totalBankValue < cost) return null;

            let bestSubset = null;
            let bestCount = -1;
            let bestTotal = Infinity;

            const n = cardsWithValues.length;
            for (let mask = 1; mask < (1 << n); mask++) {
                const subset = [];
                let total = 0;
                for (let i = 0; i < n; i++) {
                    if (mask & (1 << i)) {
                        subset.push(cardsWithValues[i].card);
                        total += cardsWithValues[i].value;
                    }
                }

                if (total >= cost) {
                    const isExact = (total === cost);
                    const bestIsExact = (bestTotal === cost);

                    const isBetter =
                        (isExact && !bestIsExact) ||                          // Exact beats non-exact
                        (isExact === bestIsExact && total < bestTotal) ||     // Lower total wins
                        (total === bestTotal && subset.length > bestCount);   // More cards as tiebreaker

                    if (isBetter) {
                        bestSubset = subset;
                        bestCount = subset.length;
                        bestTotal = total;
                    }
                }
            }

            return bestSubset;
        }

        function executeDraw() {
            // Get top card from draw pile
            const drawPile = piles.draw;
            if (drawPile.cards.length === 0) return false;

            const topCard = drawPile.cards[drawPile.cards.length - 1];
            drawPile.cards.pop();

            // Move to current player's hand
            const myHand = players[myPlayerNumber].hand;
            myHand.cards.push(topCard);

            // Layout both zones
            layoutCardsInZone(drawPile);
            layoutCardsInZone(myHand);

            consumeAction();
            sendStateUpdate();
            return true;
        }

        function executeBank(card, sourceZone, targetZone) {
            // Move card from hand to bank
            removeCardFromZones(card);
            targetZone.cards.push(card);

            layoutCardsInZone(sourceZone);
            layoutCardsInZone(targetZone);

            consumeAction();
            sendStateUpdate();
            return true;
        }

        function executePlay(card, sourceZone) {
            const cost = getCardCost(card);
            const cardName = card.userData.name;

            if (cost > 0) {
                const myBank = players[myPlayerNumber].bank;
                const payment = selectPayment(myBank.cards, cost);

                if (payment === null) {
                    return false;
                }

                for (const payCard of payment) {
                    removeCardFromZones(payCard);
                    piles.discard.cards.push(payCard);
                }
                layoutCardsInZone(myBank);
            }

            removeCardFromZones(card);
            piles.discard.cards.push(card);

            layoutCardsInZone(sourceZone);
            layoutCardsInZone(piles.discard);

            // Define card categories
            const immediateEffects = ['greed', 'insomnia'];
            const markTargetingCards = ['unmasked', 'alter ego', 'body swap'];
            const playerTargetingCards = ['tied up', 'arson'];
            const killCards = ['backfire', 'counterfeit', 'bloodshot', 'heavy hand', 'gold digger', 'red handed'];
            const bountyCards = ['hearts bounty', 'spades bounty', 'clubs bounty', 'diamonds bounty'];
            const specialCards = ['trade off', 'upheaval'];

            if (killCards.includes(cardName)) {
                // Kill cards - initiate targeting, no reaction window (lethal)
                consumeAction();
                sendStateUpdate();
                initiateKill(myPlayerNumber, card);
            } else if (markTargetingCards.includes(cardName)) {
                // Initiate targeting flow - action consumed after effect resolves
                consumeAction();
                sendStateUpdate();

                switch (cardName) {
                    case 'unmasked':
                        initiateUnmasked(myPlayerNumber, card);
                        break;
                    case 'alter ego':
                        initiateAlterEgo(myPlayerNumber, card);
                        break;
                    case 'body swap':
                        initiateBodySwap(myPlayerNumber, card);
                        break;
                }
            } else if (playerTargetingCards.includes(cardName)) {
                // Player targeting cards with reaction window
                consumeAction();
                sendStateUpdate();

                switch (cardName) {
                    case 'tied up':
                        initiateTiedUp(myPlayerNumber, card);
                        break;
                    case 'arson':
                        initiateArson(myPlayerNumber, card);
                        break;
                }
            } else if (specialCards.includes(cardName)) {
                consumeAction();
                sendStateUpdate();

                switch (cardName) {
                    case 'trade off':
                        initiateTradeOff(myPlayerNumber, card);
                        break;
                    case 'upheaval':
                        initiateUpheaval(myPlayerNumber, card);
                        break;
                }
            } else if (bountyCards.includes(cardName)) {
                // Bounty cards - immediate effect, no reaction
                initiateBounty(myPlayerNumber, card);
                consumeAction();
                sendStateUpdate();
            } else if (immediateEffects.includes(cardName)) {
                // Execute immediately without reaction window
                executeCardEffect(card, myPlayerNumber, null);
                consumeAction();
                sendStateUpdate();
            } else {
                // Other cards (snub, blind spot, revenge are reaction cards - shouldn't be played directly)
                consumeAction();
                sendStateUpdate();
            }

            return true;
        }

        function isLethalCard(cardName) {
            const lethalCards = ['backfire', 'counterfeit', 'bloodshot', 'heavy hand', 'gold digger', 'red handed'];
            return lethalCards.includes(cardName);
        }

        function isOwnZone(zone) {
            if (!zone || !myPlayerNumber) return false;
            return zone.player === myPlayerNumber;
        }

        function shouldShowFaceUp(card, zone) {
            if (!zone) return card.userData.faceUp;

            // Discard pile - always face-up
            if (zone.id === 'discard') return true;

            // Bounty pile - always face-up
            if (zone.id === 'bounty') return true;

            // Bank zones - always face-down
            if (zone.type === 'bank') return false;

            // Effect zones - always face-up (active effects are public)
            if (zone.type === 'effect') return true;

            // Mark zones - check knowledge
            if (zone.type === 'mark') {
                // Dead players' marks are revealed to everyone
                if (!playerAlive[zone.player]) return true;

                // Check if current player knows this mark
                const myKnowledge = knownMarks[myPlayerNumber];
                if (myKnowledge && myKnowledge.has(zone.player)) {
                    return true;
                }
                return false;
            }

            // Draw pile - always face-down
            if (zone.id === 'draw') return false;

            // Extra mark - always face-down
            if (zone.id === 'extra-mark') return false;

            // Hand zones - face-up only for owner
            if (zone.type === 'hand') {
                return zone.player === myPlayerNumber;
            }

            // Default: use logical state
            return card.userData.faceUp;
        }

        // === REACTION SYSTEM ===

        function startReactionWindow(card, playerId, targetId, effectType, isLethal = false) {
            const cardIndex = cards.indexOf(card);

            reactionState = {
                active: true,
                card: card,
                cardIndex: cardIndex,
                playerId: playerId,
                targetId: targetId,
                timeRemaining: 5000,
                eligibleReactors: [],
                responses: {},
                startTime: Date.now(),
                effectType: effectType,
                isLethal: isLethal
            };

            // Determine who can react (based on effect type)
            if (!isLethal) {
                // Check each player for Snub + enough bank value
                for (let pNum = 1; pNum <= 4; pNum++) {
                    if (pNum === playerId) continue;
                    if (!playerAlive[pNum]) continue;
                    if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;

                    if (canPlayerReact(pNum, 'snub')) {
                        reactionState.eligibleReactors.push(pNum);
                    }
                }
            }

            // For peek effects, target can use blindspot or revenge
            if (effectType === 'peek' && targetId) {
                if (canPlayerReact(targetId, 'blind spot')) {
                    if (!reactionState.eligibleReactors.includes(targetId)) {
                        reactionState.eligibleReactors.push(targetId);
                    }
                }
                if (canPlayerReact(targetId, 'revenge')) {
                    if (!reactionState.eligibleReactors.includes(targetId)) {
                        reactionState.eligibleReactors.push(targetId);
                    }
                }
            }

            // Show overlay
            showReactionOverlay();

            // Start countdown
            updateReactionTimer();

            // Broadcast to all players
            if (isHost) {
                broadcastReactionStart();
            } else {
                sendReactionStartToHost();
            }
        }

        function canPlayerReact(playerNum, cardName) {
            const player = players[playerNum];
            if (!player) return false;

            // Check if player has the card in hand
            const hasCard = player.hand.cards.some(c => c.userData.name === cardName);
            if (!hasCard) return false;

            // Check if player can afford the cost
            const cardDef = CARD_DEFS.find(d => d.name === cardName);
            const cost = cardDef?.cost || 0;
            const bankValue = player.bank.cards.reduce((sum, c) => sum + getCardValue(c), 0);

            return bankValue >= cost;
        }

        function showReactionOverlay() {
            const overlay = document.getElementById('reaction-overlay');
            overlay.classList.remove('hidden');

            // Show card info
            const cardDisplay = document.getElementById('reaction-card-display');
            cardDisplay.innerHTML = `<div style="color:white;text-align:center;">
                <div style="font-size:24px;">${reactionState.card.userData.name}</div>
                <div style="font-size:14px;margin-top:10px;">Played by Player ${reactionState.playerId}</div>
            </div>`;

            // Show appropriate prompt
            const buttons = document.getElementById('reaction-buttons');
            const waiting = document.getElementById('reaction-waiting');
            const message = document.getElementById('reaction-message');

            if (reactionState.eligibleReactors.includes(myPlayerNumber)) {
                message.textContent = 'You can react to this card!';
                buttons.style.display = 'flex';
                waiting.style.display = 'none';
            } else {
                message.textContent = 'Waiting for reactions...';
                buttons.style.display = 'none';
                waiting.style.display = 'block';
            }
        }

        function hideReactionOverlay() {
            const overlay = document.getElementById('reaction-overlay');
            overlay.classList.add('hidden');
        }

        function updateReactionTimer() {
            if (!reactionState.active) return;

            const elapsed = Date.now() - reactionState.startTime;
            const remaining = Math.max(0, 5000 - elapsed);
            reactionState.timeRemaining = remaining;

            const timerEl = document.getElementById('reaction-timer');
            timerEl.textContent = (remaining / 1000).toFixed(1);

            if (remaining > 0) {
                requestAnimationFrame(updateReactionTimer);
            } else {
                resolveReaction();
            }
        }

        function sendReactionResponse(response) {
            reactionState.responses[myPlayerNumber] = response;

            // Hide buttons, show waiting
            const buttons = document.getElementById('reaction-buttons');
            const waiting = document.getElementById('reaction-waiting');
            buttons.style.display = 'none';
            waiting.style.display = 'block';
            waiting.textContent = 'Response sent, waiting...';

            // Send to host/broadcast
            if (isHost) {
                checkAllReactionsReceived();
            } else if (hostConnection?.open) {
                hostConnection.send({
                    type: MSG.REACTION_RESPONSE,
                    playerId: myPlayerNumber,
                    response: response
                });
            }
        }

        function checkAllReactionsReceived() {
            // Check if all eligible reactors have responded
            const allResponded = reactionState.eligibleReactors.every(
                pNum => reactionState.responses[pNum] !== undefined
            );

            if (allResponded) {
                resolveReaction();
            }
        }

        function resolveReaction() {
            if (!reactionState.active) return;

            reactionState.active = false;
            hideReactionOverlay();

            // Check if anyone reacted
            const reactor = Object.entries(reactionState.responses).find(([_, r]) => r === 'react');

            if (reactor) {
                // Someone blocked - handle the reaction
                handleReactionBlock(parseInt(reactor[0]));
            } else {
                // No block - execute the effect
                executeCardEffect(reactionState.card, reactionState.playerId, reactionState.targetId);
            }

            // Broadcast resolution
            if (isHost) {
                broadcastReactionResolve(reactor ? parseInt(reactor[0]) : null);
            }
        }

        function broadcastReactionStart() {
            const message = {
                type: MSG.REACTION_START,
                cardIndex: reactionState.cardIndex,
                playerId: reactionState.playerId,
                targetId: reactionState.targetId,
                effectType: reactionState.effectType,
                isLethal: reactionState.isLethal,
                eligibleReactors: reactionState.eligibleReactors
            };

            for (const conn of connections.values()) {
                if (conn.open) conn.send(message);
            }
        }

        function sendReactionStartToHost() {
            // Client tells host to start reaction
            if (hostConnection?.open) {
                hostConnection.send({
                    type: MSG.REACTION_START,
                    cardIndex: reactionState.cardIndex,
                    playerId: reactionState.playerId,
                    targetId: reactionState.targetId,
                    effectType: reactionState.effectType,
                    isLethal: reactionState.isLethal
                });
            }
        }

        function broadcastReactionResolve(reactorId) {
            const message = {
                type: MSG.REACTION_RESOLVE,
                reactorId: reactorId,
                cardIndex: reactionState.cardIndex
            };

            for (const conn of connections.values()) {
                if (conn.open) conn.send(message);
            }
        }

        function handleReactionBlock(reactorPlayerNum) {
            // Find which reaction card was used
            const player = players[reactorPlayerNum];
            let reactionCard = null;
            let reactionType = null;

            // Determine which card was used based on effect type
            if (reactionState.effectType === 'peek') {
                // Could be blindspot or revenge
                reactionCard = player.hand.cards.find(c => c.userData.name === 'blind spot');
                if (reactionCard) {
                    reactionType = 'blindspot';
                } else {
                    reactionCard = player.hand.cards.find(c => c.userData.name === 'revenge');
                    reactionType = 'revenge';
                }
            } else {
                // Must be snub
                reactionCard = player.hand.cards.find(c => c.userData.name === 'snub');
                reactionType = 'snub';
            }

            if (!reactionCard) return;

            // Pay cost and discard reaction card
            const cardDef = CARD_DEFS.find(d => d.name === reactionCard.userData.name);
            const cost = cardDef?.cost || 0;

            if (cost > 0) {
                const payment = selectPayment(player.bank.cards, cost);
                if (payment) {
                    for (const payCard of payment) {
                        removeCardFromZones(payCard);
                        piles.discard.cards.push(payCard);
                    }
                    layoutCardsInZone(player.bank);
                }
            }

            removeCardFromZones(reactionCard);
            piles.discard.cards.push(reactionCard);
            layoutCardsInZone(player.hand);
            layoutCardsInZone(piles.discard);

            // Handle revenge special case - counter-peek
            if (reactionType === 'revenge' && reactionState.effectType === 'peek') {
                // Both players learn each other's marks
                addMarkKnowledge(reactionState.playerId, reactionState.targetId);
                addMarkKnowledge(reactionState.targetId, reactionState.playerId);
            }

            sendStateUpdate();
        }

        function executeCardEffect(card, playerId, targetId) {
            // This will be expanded in later phases
            const cardName = card.userData.name;

            // Dispatch to specific effect handler
            switch (cardName) {
                case 'greed':
                    executeGreed(playerId);
                    break;
                case 'insomnia':
                    executeInsomnia(playerId, card);
                    break;
                case 'unmasked':
                    executeUnmasked(playerId, targetId);
                    break;
                case 'alter ego':
                    executeAlterEgo(playerId, targetId);
                    break;
                case 'body swap':
                    executeBodySwap(playerId, targetId, reactionState.secondTarget);
                    break;
                case 'tied up':
                    executeTiedUp(playerId, targetId, card);
                    break;
                case 'arson':
                    executeArson(playerId, targetId);
                    break;
                case 'trade off':
                    executeTradeOff(playerId);
                    break;
                case 'upheaval':
                    executeUpheaval(playerId);
                    break;
                case 'hearts bounty':
                case 'spades bounty':
                case 'clubs bounty':
                case 'diamonds bounty':
                    // Bounty effects handled separately in executeBounty
                    break;
                default:
                    console.log(`Effect not implemented: ${cardName}`);
            }
        }

        function executeGreed(playerId) {
            // Draw 2 cards for the player
            const player = players[playerId];
            if (!player) return;

            // Draw first card
            if (piles.draw.cards.length > 0) {
                const card1 = piles.draw.cards.pop();
                card1.userData.faceUp = true;
                player.hand.cards.push(card1);
            }

            // Draw second card
            if (piles.draw.cards.length > 0) {
                const card2 = piles.draw.cards.pop();
                card2.userData.faceUp = true;
                player.hand.cards.push(card2);
            }

            layoutCardsInZone(piles.draw);
            layoutCardsInZone(player.hand);
            sendStateUpdate();
        }

        function executeInsomnia(playerId, card) {
            // Move insomnia card to effect zone, grant 3 extra actions
            const player = players[playerId];
            if (!player) return;

            // Find the insomnia card that was just played (should be in discard)
            const insomniaCard = card || piles.discard.cards.find(c => c.userData.name === 'insomnia');
            if (insomniaCard) {
                removeCardFromZones(insomniaCard);
                player.effect.cards.push(insomniaCard);
                layoutCardsInZone(piles.discard);
                layoutCardsInZone(player.effect);
            }

            // Grant 3 additional actions
            turnState.actionsRemaining += 3;
            updateTurnUI();
            sendStateUpdate();
        }

        // === MARK MANIPULATION EFFECTS ===

        function initiateUnmasked(playerId, card) {
            // Get valid targets (other alive players)
            const validTargets = [];
            for (let pNum = 1; pNum <= 4; pNum++) {
                if (pNum === playerId) continue;
                if (!playerAlive[pNum]) continue;
                if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;
                validTargets.push(pNum);
            }

            if (validTargets.length === 0) {
                console.log('No valid targets for Unmasked');
                return;
            }

            // Enter targeting mode
            enterTargetingMode('mark', validTargets, (targetPlayerNum) => {
                // Start reaction window
                startReactionWindow(card, playerId, targetPlayerNum, 'peek', false);
            });
        }

        function executeUnmasked(playerId, targetId) {
            // Add mark knowledge
            addMarkKnowledge(playerId, targetId);
            sendStateUpdate();
        }

        function initiateAlterEgo(playerId, card) {
            // Get valid targets (any alive player including self)
            const validTargets = [];
            for (let pNum = 1; pNum <= 4; pNum++) {
                if (!playerAlive[pNum]) continue;
                if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;
                validTargets.push(pNum);
            }

            if (validTargets.length === 0) return;

            // Enter targeting mode for mark selection
            enterTargetingMode('mark', validTargets, (targetPlayerNum) => {
                // Start reaction window
                startReactionWindow(card, playerId, targetPlayerNum, 'swap_extra', false);
            });
        }

        function executeAlterEgo(playerId, targetId) {
            const targetMarkZone = players[targetId].mark;
            const extraMarkZone = piles.extraMark;

            if (targetMarkZone.cards.length === 0 || extraMarkZone.cards.length === 0) return;

            // Swap the cards
            const targetMark = targetMarkZone.cards[0];
            const extraMark = extraMarkZone.cards[0];

            targetMarkZone.cards[0] = extraMark;
            extraMarkZone.cards[0] = targetMark;

            // Invalidate mark knowledge for this player
            invalidateMarkKnowledge(targetId);

            layoutCardsInZone(targetMarkZone);
            layoutCardsInZone(extraMarkZone);
            sendStateUpdate();
        }

        function invalidateMarkKnowledge(targetPlayerId) {
            // Anyone who knew this mark no longer knows it
            for (const viewerId of Object.keys(knownMarks)) {
                if (knownMarks[viewerId]) {
                    knownMarks[viewerId].delete(targetPlayerId);
                }
            }

            if (isHost) {
                broadcastMarkKnowledge();
            }
        }

        let bodySwapFirstTarget = null;

        function initiateBodySwap(playerId, card) {
            bodySwapFirstTarget = null;

            // Get valid targets (any alive player)
            const validTargets = [];
            for (let pNum = 1; pNum <= 4; pNum++) {
                if (!playerAlive[pNum]) continue;
                if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;
                validTargets.push(pNum);
            }

            if (validTargets.length < 2) return;

            // Enter targeting mode for first mark
            enterTargetingMode('mark', validTargets, (firstTarget) => {
                bodySwapFirstTarget = firstTarget;

                // Enter targeting mode for second mark (exclude first)
                const secondTargets = validTargets.filter(t => t !== firstTarget);
                enterTargetingMode('mark', secondTargets, (secondTarget) => {
                    // Start reaction window
                    startReactionWindow(card, playerId, firstTarget, 'swap_marks', false);
                    // Store second target for resolution
                    reactionState.secondTarget = secondTarget;
                });
            });
        }

        function executeBodySwap(playerId, target1, target2) {
            const mark1Zone = players[target1].mark;
            const mark2Zone = players[target2].mark;

            if (mark1Zone.cards.length === 0 || mark2Zone.cards.length === 0) return;

            // Swap the cards
            const mark1 = mark1Zone.cards[0];
            const mark2 = mark2Zone.cards[0];

            mark1Zone.cards[0] = mark2;
            mark2Zone.cards[0] = mark1;

            // Invalidate mark knowledge for both players
            invalidateMarkKnowledge(target1);
            invalidateMarkKnowledge(target2);

            layoutCardsInZone(mark1Zone);
            layoutCardsInZone(mark2Zone);
            sendStateUpdate();
        }

        function addMarkKnowledge(viewerPlayerId, targetPlayerId) {
            if (!knownMarks[viewerPlayerId]) {
                knownMarks[viewerPlayerId] = new Set();
            }
            knownMarks[viewerPlayerId].add(targetPlayerId);

            // Broadcast update
            if (isHost) {
                broadcastMarkKnowledge();
            }

            // Refresh card visuals
            for (const zone of zones) {
                if (zone.type === 'mark') {
                    layoutCardsInZone(zone);
                }
            }
        }

        function broadcastMarkKnowledge() {
            // Convert Sets to arrays for JSON serialization
            const serialized = {};
            for (const [viewerId, targets] of Object.entries(knownMarks)) {
                serialized[viewerId] = Array.from(targets);
            }

            const message = {
                type: MSG.MARK_KNOWLEDGE_UPDATE,
                knownMarks: serialized
            };

            for (const conn of connections.values()) {
                if (conn.open) conn.send(message);
            }
        }

        // === PHASE 4: KILL CARDS ===

        function getPlayerHandCards(playerNum) {
            return players[playerNum]?.hand.cards || [];
        }

        function getPlayerBankCards(playerNum) {
            return players[playerNum]?.bank.cards || [];
        }

        function isRedCard(card) {
            const def = CARD_DEFS.find(d => d.name === card.userData.name);
            return def?.back === 54; // Red back index
        }

        function countRedCardsInHand(playerNum) {
            return getPlayerHandCards(playerNum).filter(isRedCard).length;
        }

        function hasRedCardsInHand(playerNum, minCount) {
            return countRedCardsInHand(playerNum) >= minCount;
        }

        function hasAnyRedCardInHand(playerNum) {
            return countRedCardsInHand(playerNum) > 0;
        }

        function hasCardsInHand(playerNum, minCount) {
            return getPlayerHandCards(playerNum).length >= minCount;
        }

        function hasCardsInBank(playerNum, minCount) {
            return getPlayerBankCards(playerNum).length >= minCount;
        }

        function getValidKillTargets(cardName) {
            const validTargets = [];

            for (let pNum = 1; pNum <= 4; pNum++) {
                if (pNum === myPlayerNumber) continue;
                if (!playerAlive[pNum]) continue;
                if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;

                let meetsCondition = false;

                switch (cardName) {
                    case 'red handed':
                        meetsCondition = hasRedCardsInHand(pNum, 2);
                        break;
                    case 'counterfeit':
                        meetsCondition = hasCardsInBank(pNum, 6);
                        break;
                    case 'heavy hand':
                        meetsCondition = hasCardsInHand(pNum, 6);
                        break;
                    case 'backfire':
                        meetsCondition = hasCardsInHand(pNum, 5);
                        break;
                    case 'bloodshot':
                        meetsCondition = hasAnyRedCardInHand(pNum);
                        break;
                    case 'gold digger':
                        meetsCondition = hasCardsInBank(pNum, 5);
                        break;
                }

                if (meetsCondition) {
                    validTargets.push(pNum);
                }
            }

            return validTargets;
        }

        function initiateKill(playerId, card) {
            const cardName = card.userData.name;
            const validTargets = getValidKillTargets(cardName);

            if (validTargets.length === 0) {
                console.log('No valid targets for kill card');
                return;
            }

            enterTargetingMode('player', validTargets, (targetPlayerNum) => {
                // Kill cards are lethal - no reaction window
                executeKill(playerId, targetPlayerNum, card);
            });
        }

        function executeKill(killerNum, victimNum, killCard) {
            // 1. Collect victim's cards and sort by value
            const victimHand = players[victimNum].hand.cards.slice();
            const victimBank = players[victimNum].bank.cards.slice();
            const allVictimCards = [...victimHand, ...victimBank];

            // Sort by back value (descending)
            allVictimCards.sort((a, b) => getCardValue(b) - getCardValue(a));

            // 2. Take top 2 cards to killer's bank
            const cardsToTake = allVictimCards.slice(0, 2);
            const killerBank = players[killerNum].bank;

            for (const card of cardsToTake) {
                removeCardFromZones(card);
                killerBank.cards.push(card);
            }

            // 3. Move remaining victim cards to discard
            for (const card of allVictimCards.slice(2)) {
                removeCardFromZones(card);
                piles.discard.cards.push(card);
            }

            // 4. Move kill card to killer's effect zone
            const killerEffect = players[killerNum].effect;
            // Card should already be in discard from executePlay
            const discardIndex = piles.discard.cards.indexOf(killCard);
            if (discardIndex !== -1) {
                piles.discard.cards.splice(discardIndex, 1);
            }
            killerEffect.cards.push(killCard);

            // 5. Mark victim as dead
            playerAlive[victimNum] = false;

            // 6. Grant killer 2 bonus actions
            turnState.actionsRemaining += 2;

            // 7. Layout all affected zones
            layoutCardsInZone(players[victimNum].hand);
            layoutCardsInZone(players[victimNum].bank);
            layoutCardsInZone(players[victimNum].mark); // Will show face-up now
            layoutCardsInZone(killerBank);
            layoutCardsInZone(killerEffect);
            layoutCardsInZone(piles.discard);

            updateTurnUI();

            // 8. Check win condition
            checkVictory();

            sendStateUpdate();
        }

        function checkVictory() {
            const alivePlayers = Object.entries(playerAlive)
                .filter(([_, alive]) => alive)
                .map(([num, _]) => parseInt(num));

            // Only check among connected players
            const connectedAlivePlayers = alivePlayers.filter(pNum =>
                currentPlayerList.find(p => p.num === pNum && p.connected)
            );

            if (connectedAlivePlayers.length === 1) {
                const winner = connectedAlivePlayers[0];
                showVictoryScreen(winner);
            }
        }

        function showVictoryScreen(winnerNum) {
            const winnerName = currentPlayerList.find(p => p.num === winnerNum)?.name || `Player ${winnerNum}`;

            const overlay = document.createElement('div');
            overlay.id = 'victory-overlay';
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.9);
                z-index: 1000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: white;
            `;
            overlay.innerHTML = `
                <h1 style="font-size: 48px; margin-bottom: 20px;">Victory!</h1>
                <p style="font-size: 24px; margin-bottom: 40px;">${winnerName} wins!</p>
                <button id="play-again-btn" style="padding: 15px 30px; font-size: 18px; cursor: pointer;">
                    Play Again
                </button>
            `;
            document.body.appendChild(overlay);

            document.getElementById('play-again-btn').addEventListener('click', () => {
                location.reload();
            });
        }

        // === PHASE 5: TRADE & DISRUPTION ===

        let tradeOffFirstCard = null;

        function initiateTradeOff(playerId, card) {
            const player = players[playerId];

            // Must have at least 1 other card in hand
            const otherHandCards = player.hand.cards.filter(c => c !== card);
            if (otherHandCards.length === 0) {
                console.log('No other cards in hand for Trade Off');
                return;
            }

            // Get valid cards from own hand (excluding trade off which is in discard now)
            const ownHandIndices = player.hand.cards.map(c => cards.indexOf(c));

            enterTargetingMode('card', ownHandIndices, (ownCardIndex) => {
                tradeOffFirstCard = cards[ownCardIndex];

                // Get valid target cards (any opponent's hand or bank)
                const targetCardIndices = [];
                for (let pNum = 1; pNum <= 4; pNum++) {
                    if (pNum === playerId) continue;
                    if (!playerAlive[pNum]) continue;

                    const opponentHand = players[pNum].hand.cards;
                    const opponentBank = players[pNum].bank.cards;

                    for (const c of opponentHand) {
                        targetCardIndices.push(cards.indexOf(c));
                    }
                    for (const c of opponentBank) {
                        targetCardIndices.push(cards.indexOf(c));
                    }
                }

                if (targetCardIndices.length === 0) {
                    console.log('No valid targets for Trade Off');
                    tradeOffFirstCard = null;
                    return;
                }

                enterTargetingMode('card', targetCardIndices, (targetCardIndex) => {
                    const targetCard = cards[targetCardIndex];
                    // Start reaction window
                    startReactionWindow(card, playerId, null, 'trade', false);
                    reactionState.tradeCards = { own: tradeOffFirstCard, target: targetCard };
                });
            });
        }

        function executeTradeOff(playerId) {
            const { own, target } = reactionState.tradeCards || {};
            if (!own || !target) return;

            const ownZone = findCardZone(own);
            const targetZone = findCardZone(target);

            if (!ownZone || !targetZone) return;

            // Swap cards between zones
            const ownIndex = ownZone.cards.indexOf(own);
            const targetIndex = targetZone.cards.indexOf(target);

            ownZone.cards[ownIndex] = target;
            targetZone.cards[targetIndex] = own;

            layoutCardsInZone(ownZone);
            layoutCardsInZone(targetZone);
            sendStateUpdate();
        }

        function initiateTiedUp(playerId, card) {
            // Get valid targets (other alive players)
            const validTargets = [];
            for (let pNum = 1; pNum <= 4; pNum++) {
                if (pNum === playerId) continue;
                if (!playerAlive[pNum]) continue;
                if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;
                validTargets.push(pNum);
            }

            if (validTargets.length === 0) return;

            enterTargetingMode('player', validTargets, (targetPlayerNum) => {
                startReactionWindow(card, playerId, targetPlayerNum, 'skip', false);
            });
        }

        function executeTiedUp(playerId, targetId, card) {
            // Move tied up card from discard to target's effect zone
            const tiedUpCard = card || piles.discard.cards.find(c => c.userData.name === 'tied up');
            if (tiedUpCard) {
                removeCardFromZones(tiedUpCard);
                players[targetId].effect.cards.push(tiedUpCard);
                layoutCardsInZone(piles.discard);
                layoutCardsInZone(players[targetId].effect);
            }
            sendStateUpdate();
        }

        function processStartOfTurn(playerNum) {
            const player = players[playerNum];
            if (!player) return false;

            // Check for tied up in effect zone
            const tiedUpIndex = player.effect.cards.findIndex(c => c.userData.name === 'tied up');
            if (tiedUpIndex !== -1) {
                const tiedUpCard = player.effect.cards[tiedUpIndex];
                player.effect.cards.splice(tiedUpIndex, 1);
                piles.discard.cards.push(tiedUpCard);
                layoutCardsInZone(player.effect);
                layoutCardsInZone(piles.discard);
                sendStateUpdate();
                return true; // Skip this player's turn
            }

            return false;
        }

        function initiateArson(playerId, card) {
            // Get valid targets (other alive players with banks)
            const validTargets = [];
            for (let pNum = 1; pNum <= 4; pNum++) {
                if (pNum === playerId) continue;
                if (!playerAlive[pNum]) continue;
                if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;
                if (players[pNum].bank.cards.length === 0) continue;
                validTargets.push(pNum);
            }

            if (validTargets.length === 0) return;

            enterTargetingMode('bank', validTargets, (targetPlayerNum) => {
                startReactionWindow(card, playerId, targetPlayerNum, 'arson', false);
            });
        }

        function executeArson(playerId, targetId) {
            const targetBank = players[targetId].bank;

            // Move all bank cards to discard
            while (targetBank.cards.length > 0) {
                const card = targetBank.cards.pop();
                piles.discard.cards.push(card);
            }

            layoutCardsInZone(targetBank);
            layoutCardsInZone(piles.discard);
            sendStateUpdate();
        }

        // === PHASE 6: SPECIAL EFFECTS ===

        function initiateUpheaval(playerId, card) {
            // Start reaction window first
            startReactionWindow(card, playerId, null, 'upheaval', false);
        }

        function executeUpheaval(playerId) {
            // Show deck spread overlay
            upheavalState.active = true;

            const overlay = document.createElement('div');
            overlay.id = 'upheaval-overlay';
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.8);
                z-index: 600;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            const cardsContainer = document.createElement('div');
            cardsContainer.style.cssText = `
                display: flex;
                gap: 2px;
                position: relative;
            `;

            const deckSize = piles.draw.cards.length;
            for (let i = 0; i < deckSize; i++) {
                const cardEl = document.createElement('div');
                cardEl.style.cssText = `
                    width: 40px;
                    height: 56px;
                    background: #8B0000;
                    border: 1px solid #333;
                    border-radius: 3px;
                `;
                cardsContainer.appendChild(cardEl);
            }

            const splitIndicator = document.createElement('div');
            splitIndicator.id = 'upheaval-split';
            splitIndicator.style.cssText = `
                position: absolute;
                top: 0;
                bottom: 0;
                width: 4px;
                background: #fff;
                pointer-events: none;
                left: 0;
            `;
            cardsContainer.appendChild(splitIndicator);

            const instructions = document.createElement('div');
            instructions.style.cssText = `
                position: absolute;
                bottom: -40px;
                color: white;
                font-size: 16px;
                white-space: nowrap;
            `;
            instructions.textContent = 'Click to cut the deck';
            cardsContainer.appendChild(instructions);

            overlay.appendChild(cardsContainer);
            document.body.appendChild(overlay);

            // Track mouse for split indicator
            cardsContainer.addEventListener('mousemove', (e) => {
                const rect = cardsContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const cardWidth = 42; // 40 + 2 gap
                upheavalState.splitIndex = Math.floor(x / cardWidth);
                upheavalState.splitIndex = Math.max(1, Math.min(upheavalState.splitIndex, deckSize - 1));
                splitIndicator.style.left = (upheavalState.splitIndex * cardWidth - 2) + 'px';
            });

            // Click to cut
            overlay.addEventListener('click', () => {
                performDeckCut(upheavalState.splitIndex);
                overlay.remove();
                upheavalState.active = false;
            });
        }

        function performDeckCut(splitIndex) {
            const deck = piles.draw.cards;
            const deckSize = deck.length;

            if (splitIndex <= 0 || splitIndex >= deckSize) return;

            // Split and swap
            const bottom = deck.slice(0, splitIndex);
            const top = deck.slice(splitIndex);

            piles.draw.cards = [...top, ...bottom];

            layoutCardsInZone(piles.draw);
            sendStateUpdate();
        }

        function initiateBounty(playerId, card) {
            // No reaction window for bounty play - execute immediately
            executeBounty(playerId, card);
        }

        function executeBounty(playerId, card) {
            const player = players[playerId];

            // 1. Draw 3 cards
            for (let i = 0; i < 3; i++) {
                if (piles.draw.cards.length > 0) {
                    const drawnCard = piles.draw.cards.pop();
                    drawnCard.userData.faceUp = true;
                    player.hand.cards.push(drawnCard);
                }
            }

            // 2. Move bounty to effect zone (not discard)
            removeCardFromZones(card);
            player.effect.cards.push(card);

            // 3. Track bounty state
            const cardIndex = cards.indexOf(card);
            bountyState[cardIndex] = {
                owner: playerId,
                turnPlayed: currentTurnNumber,
                inBountyZone: false
            };

            layoutCardsInZone(piles.draw);
            layoutCardsInZone(player.hand);
            layoutCardsInZone(player.effect);
            sendStateUpdate();
        }

        function processBountyProgression(playerNum) {
            const player = players[playerNum];
            if (!player) return;

            // Check for bounties in effect zone that should move to bounty zone
            const bountiesToMove = [];
            for (const card of player.effect.cards) {
                if (card.userData.name.includes('bounty')) {
                    const cardIndex = cards.indexOf(card);
                    const state = bountyState[cardIndex];
                    if (state && !state.inBountyZone) {
                        bountiesToMove.push(card);
                        state.inBountyZone = true;
                    }
                }
            }

            for (const card of bountiesToMove) {
                removeCardFromZones(card);
                piles.bounty.cards.push(card);
            }

            if (bountiesToMove.length > 0) {
                layoutCardsInZone(player.effect);
                layoutCardsInZone(piles.bounty);
            }
        }

        function initiateBountyUse(playerNum, bountyCard) {
            // Player uses bounty from bounty zone
            const validTargets = [];
            for (let pNum = 1; pNum <= 4; pNum++) {
                if (!playerAlive[pNum]) continue;
                if (!currentPlayerList.find(p => p.num === pNum && p.connected)) continue;
                validTargets.push(pNum);
            }

            enterTargetingMode('mark', validTargets, (targetPlayerNum) => {
                executeBountyKill(playerNum, targetPlayerNum, bountyCard);
            });
        }

        function executeBountyKill(killerNum, targetNum, bountyCard) {
            const bountySuit = bountyCard.userData.name.replace(' bounty', '');
            const targetMarkZone = players[targetNum].mark;
            const targetMark = targetMarkZone.cards[0];
            const targetSuit = targetMark?.userData.name.replace(' mark', '');

            // Remove bounty from bounty zone
            removeCardFromZones(bountyCard);
            piles.discard.cards.push(bountyCard);

            if (targetSuit === bountySuit) {
                // Match! Target dies
                executeKill(killerNum, targetNum, bountyCard);
            } else {
                // No match! Killer dies
                executeKill(targetNum, killerNum, bountyCard);
            }

            layoutCardsInZone(piles.bounty);
            layoutCardsInZone(piles.discard);
            sendStateUpdate();
        }

        // === TARGETING SYSTEM ===

        function enterTargetingMode(type, validTargets, callback) {
            targetingState = {
                active: true,
                type: type,
                validTargets: validTargets,
                callback: callback,
                highlightMeshes: []
            };

            // Add visual highlights
            highlightTargets();

            // Change cursor
            renderer.domElement.style.cursor = 'crosshair';
        }

        function exitTargetingMode() {
            // Remove highlights
            for (const mesh of targetingState.highlightMeshes) {
                scene.remove(mesh);
            }

            targetingState = {
                active: false,
                type: null,
                validTargets: [],
                callback: null,
                highlightMeshes: []
            };

            renderer.domElement.style.cursor = 'default';
        }

        function highlightTargets() {
            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide
            });

            if (targetingState.type === 'player' || targetingState.type === 'mark') {
                // Highlight mark zones for valid player targets
                for (const playerNum of targetingState.validTargets) {
                    const markZone = players[playerNum]?.mark;
                    if (!markZone) continue;

                    // Swap width/height for rotated zones (Player 2 & 4)
                    const isRotated = markZone.rotation !== 0;
                    const geoWidth = isRotated ? (markZone.height + 0.5) : (markZone.width + 0.5);
                    const geoHeight = isRotated ? (markZone.width + 0.5) : (markZone.height + 0.5);
                    const geometry = new THREE.PlaneGeometry(geoWidth, geoHeight);
                    const highlight = new THREE.Mesh(geometry, highlightMaterial);
                    highlight.rotation.x = -Math.PI / 2;
                    highlight.position.set(markZone.x, -0.005, markZone.z);
                    highlight.renderOrder = -1;
                    highlight.userData.targetPlayerNum = playerNum;
                    scene.add(highlight);
                    targetingState.highlightMeshes.push(highlight);
                    console.log('Mark highlight created:', {
                        position: { x: highlight.position.x, y: highlight.position.y, z: highlight.position.z },
                        rotation: { x: highlight.rotation.x, y: highlight.rotation.y },
                        renderOrder: highlight.renderOrder,
                        zone: markZone.id,
                        geometryWidth: markZone.width + 0.5,
                        geometryHeight: markZone.height + 0.5,
                        inScene: scene.children.includes(highlight),
                        materialColor: highlightMaterial.color.getHex()
                    });
                }
            }

            if (targetingState.type === 'bank') {
                // Highlight bank zones for arson-type effects
                for (const playerNum of targetingState.validTargets) {
                    const bankZone = players[playerNum]?.bank;
                    if (!bankZone) continue;

                    // Swap width/height for rotated zones (Player 2 & 4)
                    const isRotated = bankZone.rotation !== 0;
                    const geoWidth = isRotated ? (bankZone.height + 0.5) : (bankZone.width + 0.5);
                    const geoHeight = isRotated ? (bankZone.width + 0.5) : (bankZone.height + 0.5);
                    const geometry = new THREE.PlaneGeometry(geoWidth, geoHeight);
                    const highlight = new THREE.Mesh(geometry, highlightMaterial);
                    highlight.rotation.x = -Math.PI / 2;
                    highlight.position.set(bankZone.x, -0.005, bankZone.z);
                    highlight.renderOrder = -1;
                    highlight.userData.targetPlayerNum = playerNum;
                    scene.add(highlight);
                    targetingState.highlightMeshes.push(highlight);
                }
            }

            if (targetingState.type === 'card') {
                // Highlight specific cards
                for (const cardIndex of targetingState.validTargets) {
                    const card = cards[cardIndex];
                    if (!card) continue;

                    // Swap width/height for rotated cards (Player 2 & 4)
                    const isRotated = Math.abs(card.rotation.y) > 0.1;
                    const geoWidth = isRotated ? (CARD_HEIGHT + 0.3) : (CARD_WIDTH + 0.3);
                    const geoHeight = isRotated ? (CARD_WIDTH + 0.3) : (CARD_HEIGHT + 0.3);
                    const geometry = new THREE.PlaneGeometry(geoWidth, geoHeight);
                    const highlight = new THREE.Mesh(geometry, highlightMaterial);
                    highlight.rotation.x = -Math.PI / 2;
                    highlight.position.copy(card.position);
                    highlight.position.y = -0.005;
                    highlight.renderOrder = -1;
                    highlight.userData.targetCardIndex = cardIndex;
                    scene.add(highlight);
                    targetingState.highlightMeshes.push(highlight);
                    console.log('Card highlight created:', {
                        position: { x: highlight.position.x, y: highlight.position.y, z: highlight.position.z },
                        cardPosition: { x: card.position.x, y: card.position.y, z: card.position.z },
                        rotation: { x: highlight.rotation.x, y: highlight.rotation.y },
                        renderOrder: highlight.renderOrder
                    });
                }
            }
        }

        function handleTargetClick(event) {
            if (!targetingState.active) return false;

            updateMouse(event);
            raycaster.setFromCamera(mouse, camera);

            // Check highlights first
            const highlightIntersects = raycaster.intersectObjects(targetingState.highlightMeshes);
            if (highlightIntersects.length > 0) {
                const hit = highlightIntersects[0].object;

                if (hit.userData.targetPlayerNum !== undefined) {
                    const callback = targetingState.callback;
                    const target = hit.userData.targetPlayerNum;
                    exitTargetingMode();
                    callback(target);
                    return true;
                }

                if (hit.userData.targetCardIndex !== undefined) {
                    const callback = targetingState.callback;
                    const target = hit.userData.targetCardIndex;
                    exitTargetingMode();
                    callback(target);
                    return true;
                }
            }

            return false;
        }

        // === GAME SETUP ===

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function setupGame() {
            // Clear all zones first
            for (const zone of zones) {
                zone.cards = [];
            }

            // Separate mark cards from main deck
            const markCards = cards.filter(c => c.userData.name.includes('mark'));
            const mainDeck = cards.filter(c => !c.userData.name.includes('mark'));

            // Shuffle mark cards
            shuffle(markCards);

            // Deal marks: one to each player's mark zone, one to extra-mark
            // Player mark zones are at indices: p1=9, p2=11, p3=8, p4=10 in zones array
            const playerMarkZones = [
                players[1].mark,  // p1-mark
                players[2].mark,  // p2-mark
                players[3].mark,  // p3-mark
                players[4].mark,  // p4-mark
            ];

            // Get connected player numbers
            const connectedNums = currentPlayerList
                .filter(p => p.connected)
                .map(p => p.num);

            // Deal marks to player zones
            for (let i = 0; i < 4; i++) {
                const markCard = markCards[i];
                const markZone = playerMarkZones[i];
                const playerNum = i + 1;
                const isConnected = connectedNums.includes(playerNum);

                // Face down for connected players, face up for disconnected
                markCard.userData.faceUp = !isConnected;

                markZone.cards.push(markCard);
                layoutCardsInZone(markZone, false);
            }

            // Deal 5th mark to extra-mark zone (face down)
            const extraMarkCard = markCards[4];
            extraMarkCard.userData.faceUp = false;
            piles.extraMark.cards.push(extraMarkCard);
            layoutCardsInZone(piles.extraMark, false);

            // Shuffle main deck
            shuffle(mainDeck);

            // Deal 3 cards to each connected player's hand
            let deckIndex = 0;
            for (const playerNum of connectedNums) {
                const playerHand = players[playerNum].hand;
                for (let i = 0; i < 3; i++) {
                    if (deckIndex < mainDeck.length) {
                        const card = mainDeck[deckIndex];
                        card.userData.faceUp = true;
                        playerHand.cards.push(card);
                        deckIndex++;
                    }
                }
                layoutCardsInZone(playerHand, false);
            }

            // Put remaining cards in draw pile, face down
            for (let i = deckIndex; i < mainDeck.length; i++) {
                const card = mainDeck[i];
                card.userData.faceUp = false;
                piles.draw.cards.push(card);
            }
            layoutCardsInZone(piles.draw, false);
        }

        // === STATE SERIALIZATION ===

        function serializeGameState() {
            // Serialize knownMarks (convert Sets to arrays)
            const serializedMarks = {};
            for (const [viewerId, targets] of Object.entries(knownMarks)) {
                serializedMarks[viewerId] = Array.from(targets);
            }

            const state = {
                version: 2,
                timestamp: Date.now(),
                zones: {},
                turn: {
                    currentPlayerNum: turnState.currentPlayerNum,
                    actionsRemaining: turnState.actionsRemaining,
                    gameStarted: turnState.gameStarted
                },
                playerAlive: { ...playerAlive },
                knownMarks: serializedMarks,
                bountyState: { ...bountyState },
                currentTurnNumber: currentTurnNumber
            };

            for (const zone of zones) {
                state.zones[zone.id] = zone.cards.map(card => ({
                    cardIndex: cards.indexOf(card),
                    faceUp: card.userData.faceUp
                }));
            }

            return state;
        }

        function applyGameState(state) {
            // Clear all zones
            for (const zone of zones) {
                zone.cards = [];
            }

            // Repopulate zones from state
            for (const [zoneId, cardData] of Object.entries(state.zones)) {
                const zone = zones.find(z => z.id === zoneId);
                if (!zone) continue;

                for (const { cardIndex, faceUp } of cardData) {
                    const card = cards[cardIndex];
                    if (!card) continue;

                    zone.cards.push(card);
                    card.userData.faceUp = faceUp;
                }

                // Layout cards - this handles visual rotation via shouldShowFaceUp()
                layoutCardsInZone(zone, true);
            }

            // Apply turn state if present
            if (state.turn) {
                turnState.currentPlayerNum = state.turn.currentPlayerNum;
                turnState.actionsRemaining = state.turn.actionsRemaining;
                turnState.gameStarted = state.turn.gameStarted;
                updateTurnUI();
            }

            // Apply player alive state
            if (state.playerAlive) {
                for (const [pNum, alive] of Object.entries(state.playerAlive)) {
                    playerAlive[parseInt(pNum)] = alive;
                }
            }

            // Apply mark knowledge (convert arrays back to Sets)
            if (state.knownMarks) {
                knownMarks = {};
                for (const [viewerId, targets] of Object.entries(state.knownMarks)) {
                    knownMarks[viewerId] = new Set(targets);
                }
            }

            // Apply bounty state
            if (state.bountyState) {
                bountyState = { ...state.bountyState };
            }

            // Apply turn number
            if (state.currentTurnNumber !== undefined) {
                currentTurnNumber = state.currentTurnNumber;
            }
        }

        // === NETWORK FUNCTIONS ===

        function sendStateUpdate() {
            if (!peer) return; // Single-player or not connected

            const state = serializeGameState();

            if (isHost) {
                // Host: broadcast to all clients immediately
                // Set flag to ignore incoming state updates briefly
                ignoreNextStateUpdate = true;
                setTimeout(() => { ignoreNextStateUpdate = false; }, 100);
                broadcastState(state);
            } else if (hostConnection && hostConnection.open) {
                // Client: send to host
                // Set flag to ignore incoming broadcasts briefly (same as host)
                ignoreNextStateUpdate = true;
                setTimeout(() => { ignoreNextStateUpdate = false; }, 200);
                hostConnection.send({
                    type: MSG.STATE_UPDATE,
                    gameState: state
                });
            }
        }

        function broadcastState(state) {
            const message = {
                type: MSG.STATE_BROADCAST,
                gameState: state
            };

            for (const conn of connections.values()) {
                if (conn.open) {
                    conn.send(message);
                }
            }
        }

        function getPlayerList() {
            const list = [];
            for (let i = 1; i <= 4; i++) {
                let connected = false;
                let playerId = null;
                let name = null;

                if (i === 1 && isHost) {
                    connected = true;
                    playerId = myPlayerId;
                    name = myPlayerName;
                } else {
                    // Check if any player has this slot
                    for (const [pid, slot] of playerSlots.entries()) {
                        if (slot === i) {
                            playerId = pid;
                            name = playerNames.get(pid) || null;
                            // Check if connected
                            for (const [peerId, connPlayerId] of peerToPlayer.entries()) {
                                if (connPlayerId === pid && connections.get(peerId)?.open) {
                                    connected = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }

                list.push({ num: i, connected, name });
            }
            return list;
        }

        function broadcastPlayerList() {
            const list = getPlayerList();
            const message = { type: MSG.PLAYER_LIST, players: list };

            for (const conn of connections.values()) {
                if (conn.open) {
                    conn.send(message);
                }
            }

            // Update host's own UI
            updateLobbyPlayerList(list);
            updatePlayerLabels();
        }

        function handleIncomingConnection(conn) {
            conn.on('open', () => {
                conn.on('data', (data) => handlePeerMessage(conn, data));
                conn.on('close', () => handlePeerDisconnect(conn));
            });
        }

        function handlePeerMessage(conn, data) {
            switch (data.type) {
                case MSG.JOIN_REQUEST: {
                    const { playerId, playerName } = data;
                    console.log(`[Host] Join request from "${playerName}" (${playerId})`);

                    // Store player name
                    if (playerName) {
                        playerNames.set(playerId, playerName);
                    }

                    // Check for reconnection
                    if (playerSlots.has(playerId)) {
                        // Reconnecting player - same slot
                        const playerNum = playerSlots.get(playerId);
                        console.log(`[Host] Reconnecting player to slot ${playerNum}`);
                        acceptPlayer(conn, playerId, playerNum);
                    } else if (playerSlots.size < 4) {
                        // New player - find next slot
                        const playerNum = getNextPlayerSlot();
                        playerSlots.set(playerId, playerNum);
                        console.log(`[Host] New player assigned to slot ${playerNum}`);
                        acceptPlayer(conn, playerId, playerNum);
                    } else {
                        console.log(`[Host] Rejected - game is full`);
                        conn.send({ type: MSG.JOIN_REJECTED, reason: 'Game is full' });
                    }
                    break;
                }

                case MSG.STATE_UPDATE: {
                    // Apply state and broadcast to all (last-write-wins)
                    // Skip applying if host just made a local change
                    if (!ignoreNextStateUpdate) {
                        applyGameState(data.gameState);
                    }
                    broadcastState(data.gameState);
                    break;
                }

                case MSG.REACTION_RESPONSE: {
                    // Client sent a reaction response to host
                    reactionState.responses[data.playerId] = data.response;
                    checkAllReactionsReceived();
                    break;
                }
            }
        }

        function getNextPlayerSlot() {
            const usedSlots = new Set(playerSlots.values());
            usedSlots.add(1); // Host is always slot 1
            for (let i = 2; i <= 4; i++) {
                if (!usedSlots.has(i)) return i;
            }
            return null;
        }

        function acceptPlayer(conn, playerId, playerNum) {
            connections.set(conn.peer, conn);
            peerToPlayer.set(conn.peer, playerId);

            console.log(`[Host] Accepting player ${playerNum}, sending game state`);
            conn.send({
                type: MSG.JOIN_ACCEPTED,
                playerNumber: playerNum,
                gameState: serializeGameState(),
                playerList: getPlayerList()
            });

            console.log(`[Host] Broadcasting updated player list`);
            broadcastPlayerList();
        }

        function handlePeerDisconnect(conn) {
            const playerId = peerToPlayer.get(conn.peer);
            const playerNum = playerSlots.get(playerId);
            const playerName = playerNames.get(playerId);
            console.log(`[Host] Player disconnected: "${playerName}" (slot ${playerNum}, id: ${playerId})`);

            connections.delete(conn.peer);
            peerToPlayer.delete(conn.peer);
            // Keep playerSlots entry for reconnection

            // If disconnected player was current turn, advance to next connected player
            if (turnState.gameStarted && turnState.currentPlayerNum === playerNum) {
                // Update player list first so getNextConnectedPlayer works correctly
                currentPlayerList = getPlayerList();
                advanceTurn();
                // Broadcast the turn change with state
                broadcastState(serializeGameState());
            }

            console.log(`[Host] Broadcasting updated player list`);
            broadcastPlayerList();
        }

        function handleHostMessage(data) {
            switch (data.type) {
                case MSG.JOIN_ACCEPTED:
                    myPlayerNumber = data.playerNumber;
                    updateLobbyPlayerList(data.playerList);
                    applyGameState(data.gameState);
                    hideLobby();
                    showPlayerIndicator();
                    updatePlayerLabels();
                    break;

                case MSG.JOIN_REJECTED:
                    showLobbyError(data.reason);
                    break;

                case MSG.STATE_BROADCAST:
                    if (!ignoreNextStateUpdate) {
                        applyGameState(data.gameState);
                    }
                    break;

                case MSG.PLAYER_LIST:
                    updateLobbyPlayerList(data.players);
                    updatePlayerLabels();
                    break;

                case MSG.REACTION_START: {
                    // Host tells clients to start reaction window
                    reactionState = {
                        active: true,
                        card: cards[data.cardIndex],
                        cardIndex: data.cardIndex,
                        playerId: data.playerId,
                        targetId: data.targetId,
                        timeRemaining: 5000,
                        eligibleReactors: data.eligibleReactors,
                        responses: {},
                        startTime: Date.now(),
                        effectType: data.effectType,
                        isLethal: data.isLethal
                    };
                    showReactionOverlay();
                    updateReactionTimer();
                    break;
                }

                case MSG.REACTION_RESOLVE: {
                    // Host tells clients that reaction resolved
                    reactionState.active = false;
                    hideReactionOverlay();
                    // Effects already applied by host
                    break;
                }

                case MSG.MARK_KNOWLEDGE_UPDATE: {
                    // Host broadcasts updated mark knowledge
                    knownMarks = {};
                    for (const [viewerId, targets] of Object.entries(data.knownMarks)) {
                        knownMarks[viewerId] = new Set(targets);
                    }
                    // Refresh mark visuals
                    for (const zone of zones) {
                        if (zone.type === 'mark') {
                            layoutCardsInZone(zone);
                        }
                    }
                    break;
                }
            }
        }

        // === LOBBY UI ===

        function showLobby() {
            const lobby = document.createElement('div');
            lobby.id = 'lobby';
            lobby.innerHTML = `
                <h1>Hidden Marks</h1>
                <div id="lobby-content">
                    <input type="text" id="name-input" maxlength="20" placeholder="Enter your name" style="margin-bottom: 1rem;" />
                    <div class="buttons">
                        <button id="host-btn" disabled>Host Game</button>
                        <button id="join-btn" disabled>Join Game</button>
                    </div>
                </div>
            `;
            document.body.appendChild(lobby);

            const nameInput = document.getElementById('name-input');
            const hostBtn = document.getElementById('host-btn');
            const joinBtn = document.getElementById('join-btn');

            nameInput.addEventListener('input', () => {
                const hasName = nameInput.value.trim().length > 0;
                hostBtn.disabled = !hasName;
                joinBtn.disabled = !hasName;
            });

            hostBtn.addEventListener('click', () => {
                myPlayerName = nameInput.value.trim();
                hostGame();
            });
            joinBtn.addEventListener('click', () => {
                myPlayerName = nameInput.value.trim();
                showJoinScreen();
            });

            nameInput.focus();
        }

        function showJoinScreen() {
            const content = document.getElementById('lobby-content');
            content.innerHTML = `
                <p>Enter room code:</p>
                <input type="text" id="room-input" maxlength="6" placeholder="000000" />
                <div class="buttons" style="margin-top: 1rem;">
                    <button id="connect-btn">Connect</button>
                </div>
                <button class="back-btn" id="back-btn">Back</button>
                <div id="lobby-error" class="error"></div>
            `;

            const input = document.getElementById('room-input');
            input.focus();
            input.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') joinGame(input.value);
            });

            document.getElementById('connect-btn').addEventListener('click', () => joinGame(input.value));
            document.getElementById('back-btn').addEventListener('click', () => {
                document.getElementById('lobby').remove();
                showLobby();
            });
        }

        function showHostScreen() {
            const content = document.getElementById('lobby-content');
            content.innerHTML = `
                <p>Room Code:</p>
                <div class="room-code">${roomCode}</div>
                <p>Share this code with other players</p>
                <div class="player-list" id="player-list"></div>
                <button id="start-btn" style="margin-top: 1.5rem;">Start Game</button>
            `;

            updateLobbyPlayerList(getPlayerList());

            document.getElementById('start-btn').addEventListener('click', () => {
                currentPlayerList = getPlayerList();

                // Setup game - deal marks and cards
                setupGame();

                // Initialize turn state
                turnState.gameStarted = true;
                turnState.currentPlayerNum = 1; // Host starts
                turnState.actionsRemaining = 3;

                hideLobby();
                showPlayerIndicator();
                updatePlayerLabels();
                updateTurnUI();

                // Broadcast state with turn info
                sendStateUpdate();
            });
        }

        function updateLobbyPlayerList(players) {
            currentPlayerList = players;

            const listEl = document.getElementById('player-list');
            if (!listEl) return;

            listEl.innerHTML = players.map(p => {
                const displayName = p.name || `Player ${p.num}`;
                const status = p.connected ? '' : '...';
                return `<div class="${p.connected ? 'connected' : ''}">
                    ${displayName} ${status}
                </div>`;
            }).join('');
        }

        function showLobbyError(message) {
            const errorEl = document.getElementById('lobby-error');
            if (errorEl) errorEl.textContent = message;
        }

        function hideLobby() {
            const lobby = document.getElementById('lobby');
            if (lobby) lobby.remove();
        }

        function showPlayerIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'player-indicator';
            indicator.textContent = `You: ${myPlayerName}`;
            document.body.appendChild(indicator);
        }

        // === HOST/JOIN FLOWS ===

        async function hostGame() {
            getOrCreatePlayerId();
            roomCode = generateRoomCode();

            const content = document.getElementById('lobby-content');
            content.innerHTML = `<p>Creating room...</p>`;

            peer = new Peer(roomCode);

            peer.on('open', () => {
                isHost = true;
                myPlayerNumber = 1;
                playerSlots.set(myPlayerId, 1);
                playerNames.set(myPlayerId, myPlayerName);
                showHostScreen();
            });

            peer.on('connection', handleIncomingConnection);

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                content.innerHTML = `
                    <p class="error">Failed to create room: ${err.type}</p>
                    <button class="back-btn" id="back-btn">Back</button>
                `;
                document.getElementById('back-btn').addEventListener('click', () => {
                    document.getElementById('lobby').remove();
                    showLobby();
                });
            });
        }

        async function joinGame(code) {
            if (!code || code.length !== 6) {
                showLobbyError('Please enter a 6-digit code');
                return;
            }

            getOrCreatePlayerId();
            roomCode = code;

            const content = document.getElementById('lobby-content');
            content.innerHTML = `<p>Connecting to ${code}...</p>`;

            peer = new Peer();

            peer.on('open', () => {
                hostConnection = peer.connect(code, { reliable: true });

                hostConnection.on('open', () => {
                    hostConnection.send({
                        type: MSG.JOIN_REQUEST,
                        playerId: myPlayerId,
                        playerName: myPlayerName
                    });
                });

                hostConnection.on('data', handleHostMessage);

                hostConnection.on('close', () => {
                    // Attempt reconnection
                    setTimeout(() => {
                        if (roomCode && !document.getElementById('lobby')) {
                            showLobby();
                            showLobbyError('Disconnected from host');
                        }
                    }, 1000);
                });

                hostConnection.on('error', (err) => {
                    showLobbyError(`Connection error: ${err.type}`);
                });
            });

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    showLobbyError('Room not found');
                } else {
                    showLobbyError(`Error: ${err.type}`);
                }
                showJoinScreen();
            });
        }

        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        function animateCardToZone(card, zone, targetY) {
            // Remove any existing animation for this card
            animatingCards = animatingCards.filter(a => a.card !== card);
            animatingCards.push({
                card,
                startPos: card.position.clone(),
                endPos: new THREE.Vector3(zone.x, targetY, zone.z),
                startRot: card.rotation.y,
                endRot: zone.rotation,
                startTime: performance.now(),
                duration: 300
            });
        }

        function updateAnimations() {
            const now = performance.now();
            animatingCards = animatingCards.filter(anim => {
                const elapsed = now - anim.startTime;
                const t = Math.min(elapsed / anim.duration, 1);
                const eased = easeInOut(t);

                anim.card.position.lerpVectors(anim.startPos, anim.endPos, eased);
                anim.card.rotation.y = anim.startRot + (anim.endRot - anim.startRot) * eased;

                // Handle Z rotation for flip animation with arc motion
                if (anim.startRotZ !== undefined) {
                    anim.card.rotation.z = anim.startRotZ + (anim.endRotZ - anim.startRotZ) * eased;
                    // Arc motion: lift up in middle, back down at end
                    anim.card.position.y = anim.baseY + anim.liftHeight * Math.sin(t * Math.PI);
                }

                return t < 1;
            });
        }

        function getCardPositionInZone(zone, index, total) {
            const pos = { x: zone.x, y: index * CARD_DEPTH, z: zone.z };

            if (!zone.spreadAxis || total <= 1) {
                return pos;
            }

            const maxSpread = zone.width - CARD_WIDTH;
            const spacing = Math.min(CARD_WIDTH * 0.8, maxSpread / (total - 1));
            const totalWidth = spacing * (total - 1);
            const startOffset = -totalWidth / 2;
            const offset = startOffset + index * spacing;
            const dir = zone.spreadDir || 1;

            if (zone.spreadAxis === 'x') {
                pos.x = zone.x + offset * dir;
            } else {
                pos.z = zone.z + offset * dir;
            }

            return pos;
        }

        function layoutCardsInZone(zone, animate = true) {
            const count = zone.cards.length;
            zone.cards.forEach((card, i) => {
                const pos = getCardPositionInZone(zone, i, count);
                const visualFaceUp = shouldShowFaceUp(card, zone);
                const targetRotZ = visualFaceUp ? 0 : Math.PI;

                if (animate) {
                    const needsFlip = card.rotation.z !== targetRotZ;
                    animatingCards = animatingCards.filter(a => a.card !== card);
                    animatingCards.push({
                        card,
                        startPos: card.position.clone(),
                        endPos: new THREE.Vector3(pos.x, pos.y, pos.z),
                        startRot: card.rotation.y,
                        endRot: zone.rotation,
                        startRotZ: card.rotation.z,
                        endRotZ: targetRotZ,
                        liftHeight: needsFlip ? 2 : 0,
                        baseY: pos.y,
                        startTime: performance.now(),
                        duration: 300
                    });
                } else {
                    card.position.set(pos.x, pos.y, pos.z);
                    card.rotation.y = zone.rotation;
                    card.rotation.z = targetRotZ;
                }
            });
        }

        async function init() {
            // Load sprite sheet first
            await loadSpriteSheet();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            const aspect = 1920 / 1080;
            const frustumSize = 20;
            camera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                0.1, 100
            );
            camera.position.set(0, 20, 0);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);

            // Calculate letterboxed size
            const targetAspect = 1920 / 1080;
            const windowAspect = window.innerWidth / window.innerHeight;
            let width, height;
            if (windowAspect > targetAspect) {
                height = window.innerHeight;
                width = height * targetAspect;
            } else {
                width = window.innerWidth;
                height = width / targetAspect;
            }
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const tableGeometry = new THREE.PlaneGeometry(30, 20);
            const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.rotation.x = -Math.PI / 2;
            table.position.y = -0.01;
            scene.add(table);

            createZoneVisuals();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createDeck();
            setupEvents();
            animate();

            // Wire up reaction button handlers
            document.getElementById('react-btn').addEventListener('click', () => {
                sendReactionResponse('react');
            });
            document.getElementById('pass-btn').addEventListener('click', () => {
                sendReactionResponse('pass');
            });
        }

        function createZoneVisuals() {
            const zoneMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });

            for (const zone of zones) {
                const w = zone.width / 2;
                const h = zone.height / 2;
                const points = [
                    new THREE.Vector3(-w, 0, -h),
                    new THREE.Vector3(w, 0, -h),
                    new THREE.Vector3(w, 0, h),
                    new THREE.Vector3(-w, 0, h),
                    new THREE.Vector3(-w, 0, -h),
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, zoneMaterial);
                line.position.set(zone.x, 0.001, zone.z);
                line.rotation.y = zone.rotation;
                scene.add(line);
            }
        }

        let spriteSheet = null;
        let spriteCardWidth = 0;
        let spriteCardHeight = 0;

        function loadSpriteSheet() {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    spriteSheet = img;
                    spriteCardWidth = img.width / SPRITE_COLS;
                    spriteCardHeight = img.height / SPRITE_ROWS;
                    resolve();
                };
                img.src = 'spritesheet.png';
            });
        }

        const textureCache = new Map();

        function createSpriteTexture(index) {
            // Return cached texture if exists
            if (textureCache.has(index)) {
                return textureCache.get(index);
            }

            const canvas = document.createElement('canvas');
            canvas.width = spriteCardWidth;
            canvas.height = spriteCardHeight;
            const ctx = canvas.getContext('2d');

            // Calculate sprite position (1-based index)
            const i = index - 1;
            const col = i % SPRITE_COLS;
            const row = Math.floor(i / SPRITE_COLS);
            const sx = col * spriteCardWidth;
            const sy = row * spriteCardHeight;

            // Draw at native resolution - no upscaling
            ctx.drawImage(spriteSheet, sx, sy, spriteCardWidth, spriteCardHeight, 0, 0, spriteCardWidth, spriteCardHeight);

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.NoColorSpace;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            // Cache and return
            textureCache.set(index, texture);
            return texture;
        }

        function createDeck() {
            const drawPile = piles.draw;
            let cardStackIndex = 0;

            CARD_DEFS.forEach((cardDef) => {
                const copies = cardDef.count || 1;

                for (let c = 0; c < copies; c++) {
                    const faceTexture = createSpriteTexture(cardDef.index);
                    const backTexture = createSpriteTexture(cardDef.back);

                    const materials = [
                        new THREE.MeshBasicMaterial({ color: 0xffffff }),
                        new THREE.MeshBasicMaterial({ color: 0xffffff }),
                        new THREE.MeshBasicMaterial({ map: faceTexture }),
                        new THREE.MeshBasicMaterial({ map: backTexture }),
                        new THREE.MeshBasicMaterial({ color: 0xffffff }),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    ];

                    const geometry = new THREE.BoxGeometry(CARD_WIDTH, CARD_DEPTH, CARD_HEIGHT);
                    const card = new THREE.Mesh(geometry, materials);

                    card.position.set(drawPile.x, cardStackIndex * CARD_DEPTH, drawPile.z);

                    card.userData = { index: cardDef.index, name: cardDef.name, faceUp: true };
                    cards.push(card);
                    drawPile.cards.push(card);
                    scene.add(card);

                    cardStackIndex++;
                }
            });
        }

        function setupEvents() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onResize);
        }

        function updateMouse(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onMouseDown(event) {
            // Check for targeting mode first
            if (targetingState.active) {
                if (handleTargetClick(event)) {
                    return;
                }
            }

            updateMouse(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cards);

            if (intersects.length === 0) return;

            const clickedCard = intersects[0].object;

            // Check for draw action (clicking draw pile)
            if (turnState.gameStarted && piles.draw.cards.includes(clickedCard)) {
                if (canPerformAction()) {
                    // Execute draw action - top card goes to hand
                    const topCard = piles.draw.cards[piles.draw.cards.length - 1];
                    if (clickedCard === topCard) {
                        executeDraw();
                    }
                }
                return; // Don't allow dragging from draw pile
            }

            // Check for bounty use (clicking bounty zone card)
            if (turnState.gameStarted && piles.bounty.cards.includes(clickedCard)) {
                if (canPerformAction() && playerAlive[myPlayerNumber]) {
                    initiateBountyUse(myPlayerNumber, clickedCard);
                }
                return; // Don't allow dragging from bounty zone
            }

            // If game started, only allow dragging own hand cards during your turn
            if (turnState.gameStarted) {
                const myHand = players[myPlayerNumber]?.hand;
                if (!canPerformAction() || !myHand?.cards.includes(clickedCard)) {
                    return; // Can't drag if not your turn or not your hand card
                }
            }

            // Standard drag initialization
            draggedCard = clickedCard;
            dragStartPos.copy(draggedCard.position);

            const maxY = Math.max(...cards.map(c => c.position.y));
            draggedCard.position.y = maxY + CARD_DEPTH + 0.5;

            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(tablePlane, intersectPoint);
            dragOffset.copy(draggedCard.position).sub(intersectPoint);
            dragOffset.y = draggedCard.position.y;

            // Store source zone for action classification
            draggedCard.userData.sourceZone = findCardZone(draggedCard);
        }

        function onMouseMove(event) {
            if (!draggedCard) return;

            updateMouse(event);
            raycaster.setFromCamera(mouse, camera);

            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(tablePlane, intersectPoint);

            draggedCard.position.x = intersectPoint.x + dragOffset.x;
            draggedCard.position.z = intersectPoint.z + dragOffset.z;
        }

        function findNearestZone(x, z) {
            let nearest = zones[0];
            let minDist = Infinity;
            for (const zone of zones) {
                const dist = Math.hypot(x - zone.x, z - zone.z);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = zone;
                }
            }
            return nearest;
        }

        function removeCardFromZones(card) {
            for (const zone of zones) {
                const idx = zone.cards.indexOf(card);
                if (idx !== -1) {
                    zone.cards.splice(idx, 1);
                    return zone;
                }
            }
            return null;
        }

        function flipCard(card) {
            card.userData.faceUp = !card.userData.faceUp;
            const targetRotZ = card.userData.faceUp ? 0 : Math.PI;

            // Remove any existing animation for this card
            animatingCards = animatingCards.filter(a => a.card !== card);
            animatingCards.push({
                card,
                startPos: card.position.clone(),
                endPos: card.position.clone(),
                startRotZ: card.rotation.z,
                endRotZ: targetRotZ,
                startRot: card.rotation.y,
                endRot: card.rotation.y,
                liftHeight: 2,
                baseY: card.position.y,
                startTime: performance.now(),
                duration: 300
            });
        }

        function onMouseUp() {
            if (!draggedCard) return;

            // Check if it was a click (minimal movement) vs drag
            const dx = draggedCard.position.x - dragStartPos.x;
            const dz = draggedCard.position.z - dragStartPos.z;
            const distMoved = Math.sqrt(dx * dx + dz * dz);

            if (distMoved < 0.5) {
                // It's a click - flip the card
                // Return card to original position first
                draggedCard.position.x = dragStartPos.x;
                draggedCard.position.z = dragStartPos.z;
                draggedCard.position.y = dragStartPos.y;

                // Only allow flipping before game starts (free play mode)
                if (!turnState.gameStarted) {
                    flipCard(draggedCard);
                    sendStateUpdate();
                }
            } else {
                // It's a drag
                const sourceZone = draggedCard.userData.sourceZone;
                const targetZone = findNearestZone(draggedCard.position.x, draggedCard.position.z);

                if (turnState.gameStarted) {
                    // Turn-based mode: validate and execute action
                    const myHand = players[myPlayerNumber]?.hand;
                    const myBank = players[myPlayerNumber]?.bank;

                    if (sourceZone === myHand && targetZone === myBank) {
                        // Bank action: hand -> bank
                        executeBank(draggedCard, sourceZone, targetZone);
                    } else if (sourceZone === myHand && !isOwnZone(targetZone)) {
                        // Play action: hand -> outside own zones -> discard
                        if (!executePlay(draggedCard, sourceZone)) {
                            // Can't afford - return card to hand
                            draggedCard.position.copy(dragStartPos);
                            layoutCardsInZone(sourceZone);
                        }
                    } else {
                        // Invalid action - return card to original position
                        draggedCard.position.copy(dragStartPos);
                        layoutCardsInZone(sourceZone);
                    }
                } else {
                    // Free play mode (before game starts) - existing behavior
                    const oldZone = removeCardFromZones(draggedCard);
                    targetZone.cards.push(draggedCard);

                    if (oldZone && oldZone !== targetZone) {
                        layoutCardsInZone(oldZone);
                    }
                    layoutCardsInZone(targetZone);
                    sendStateUpdate();
                }
            }

            draggedCard.userData.sourceZone = null;
            draggedCard = null;
        }

        function onResize() {
            const targetAspect = 1920 / 1080;
            const windowAspect = window.innerWidth / window.innerHeight;

            let width, height;
            if (windowAspect > targetAspect) {
                // Window is wider than 16:9 - pillarbox (black bars on sides)
                height = window.innerHeight;
                width = height * targetAspect;
            } else {
                // Window is taller than 16:9 - letterbox (black bars top/bottom)
                width = window.innerWidth;
                height = width / targetAspect;
            }

            renderer.setSize(width, height);
            // Camera frustum stays fixed at 16:9
        }

        function animate() {
            requestAnimationFrame(animate);
            updateAnimations();
            renderer.render(scene, camera);
        }

        // Initialize game first, then show lobby over it
        init().then(() => showLobby());
    </script>
    <div id="reaction-overlay" class="reaction-overlay hidden">
        <div class="reaction-card-display" id="reaction-card-display"></div>
        <div class="reaction-timer" id="reaction-timer">5.0</div>
        <div class="reaction-prompt" id="reaction-prompt">
            <p id="reaction-message">Waiting...</p>
            <div class="reaction-buttons" id="reaction-buttons" style="display:none;">
                <button class="react-btn" id="react-btn">Use Card</button>
                <button class="pass-btn" id="pass-btn">Pass</button>
            </div>
            <p class="reaction-waiting" id="reaction-waiting" style="display:none;">Waiting for other players...</p>
        </div>
    </div>
</body>
</html>
