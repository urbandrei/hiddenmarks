<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Table</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; }
        #lobby { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; background: #222; color: #fff; }
        #lobby button { cursor: pointer; }
        #lobby button:hover { filter: brightness(1.2); }
        #lobby button:disabled { opacity: 0.5; cursor: not-allowed; }
        .player-label { position: fixed; z-index: 100; pointer-events: none; background: rgba(0,0,0,0.6); color: #fff; padding: 0.3rem 0.5rem; }
        .player-label.bottom { bottom: 10px; left: 50%; transform: translateX(-50%); }
        .player-label.top { top: 10px; left: 50%; transform: translateX(-50%); }
        .player-label.left { left: 10px; top: 50%; transform: translateY(-50%); }
        .player-label.right { right: 10px; top: 50%; transform: translateY(-50%); }
        #player-indicator, #action-counter { position: fixed; top: 10px; z-index: 100; background: rgba(0,0,0,0.5); color: #fff; padding: 0.3rem; }
        #player-indicator { left: 10px; }
        #action-counter { right: 10px; }
    </style>
</head>
<body>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        const CARD_WIDTH = 2.5;
        const CARD_HEIGHT = 3.5;
        const CARD_DEPTH = 0.02;

        // Card definitions from sprite sheet (10 cols x 6 rows)
        // Back indices: 54=red, 55=blue, 56=white, 57=mark
        const CARD_DEFS = [
            // White back (56)
            { index: 1, name: 'body swap', back: 56, count: 2 },
            { index: 3, name: 'alter ego', back: 56, count: 2 },
            { index: 5, name: 'greed', back: 56, count: 2 },
            { index: 7, name: 'tied up', back: 56, count: 2 },
            { index: 9, name: 'revenge', back: 56, count: 2 },
            { index: 11, name: 'insomnia', back: 56, count: 2 },
            { index: 13, name: 'blind spot', back: 56, count: 2 },
            { index: 15, name: 'trade off', back: 56, count: 4 },
            { index: 19, name: 'unmasked', back: 56, count: 4 },
            // Blue back (55)
            { index: 23, name: 'upheaval', back: 55, count: 2 },
            { index: 25, name: 'arson', back: 55, count: 2 },
            { index: 27, name: 'snub', back: 55, count: 4 },
            { index: 31, name: 'red handed', back: 55, count: 2 },
            { index: 33, name: 'counterfeit', back: 55, count: 3 },
            { index: 36, name: 'heavy hand', back: 55, count: 3 },
            // Red back (54)
            { index: 39, name: 'clubs bounty', back: 54, count: 1 },
            { index: 40, name: 'hearts bounty', back: 54, count: 1 },
            { index: 41, name: 'spades bounty', back: 54, count: 1 },
            { index: 42, name: 'diamonds bounty', back: 54, count: 1 },
            { index: 43, name: 'jokers bounty', back: 54, count: 1 },
            { index: 44, name: 'backfire', back: 54, count: 2 },
            { index: 46, name: 'bloodshot', back: 54, count: 1 },
            { index: 47, name: 'gold digger', back: 54, count: 2 },
            // Mark back (57)
            { index: 49, name: 'hearts mark', back: 57, count: 1 },
            { index: 50, name: 'spades mark', back: 57, count: 1 },
            { index: 51, name: 'clubs mark', back: 57, count: 1 },
            { index: 52, name: 'diamonds mark', back: 57, count: 1 },
            { index: 53, name: 'jokers mark', back: 57, count: 1 },
        ];
        const SPRITE_COLS = 10;
        const SPRITE_ROWS = 6;

        const GAP = 0.5;
        const ZONE_LENGTH = 15;
        const MARK_WIDTH = CARD_WIDTH;
        const EFFECT_WIDTH = CARD_WIDTH * 1.5;
        const BANK_WIDTH = ZONE_LENGTH - MARK_WIDTH - EFFECT_WIDTH - GAP * 2;
        const zones = [
            // Player hands (edge zones - half off screen, stretched along edge)
            { id: 'p3-hand', type: 'hand', player: 3, x: 0, z: -10, rotation: 0, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-hand', type: 'hand', player: 1, x: 0, z: 10, rotation: 0, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-hand', type: 'hand', player: 4, x: -15, z: 0, rotation: Math.PI/2, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-hand', type: 'hand', player: 2, x: 15, z: 0, rotation: Math.PI/2, width: ZONE_LENGTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Player banks (inner zones - overlapped by hands, stretched along edge)
            { id: 'p3-bank', type: 'bank', player: 3, x: 0, z: -10 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, rotation: 0, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-bank', type: 'bank', player: 1, x: 0, z: 10 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, rotation: 0, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-bank', type: 'bank', player: 4, x: -15 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, z: 0, rotation: Math.PI/2, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-bank', type: 'bank', player: 2, x: 15 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, z: 0, rotation: Math.PI/2, width: BANK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Player mark zones (left of bank when facing center)
            { id: 'p3-mark', type: 'mark', player: 3, x: BANK_WIDTH/2 + GAP + MARK_WIDTH/2, z: -10 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, rotation: 0, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-mark', type: 'mark', player: 1, x: -BANK_WIDTH/2 - GAP - MARK_WIDTH/2, z: 10 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, rotation: 0, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-mark', type: 'mark', player: 4, x: -15 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, z: BANK_WIDTH/2 + GAP + MARK_WIDTH/2, rotation: Math.PI/2, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-mark', type: 'mark', player: 2, x: 15 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, z: -BANK_WIDTH/2 - GAP - MARK_WIDTH/2, rotation: Math.PI/2, width: MARK_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Player effect zones (right of bank when facing center)
            { id: 'p3-effect', type: 'effect', player: 3, x: -BANK_WIDTH/2 - GAP - EFFECT_WIDTH/2, z: -10 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, rotation: 0, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p1-effect', type: 'effect', player: 1, x: BANK_WIDTH/2 + GAP + EFFECT_WIDTH/2, z: 10 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, rotation: 0, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'x', cards: [] },
            { id: 'p4-effect', type: 'effect', player: 4, x: -15 + CARD_HEIGHT/2 + GAP + CARD_HEIGHT/2, z: -BANK_WIDTH/2 - GAP - EFFECT_WIDTH/2, rotation: Math.PI/2, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            { id: 'p2-effect', type: 'effect', player: 2, x: 15 - CARD_HEIGHT/2 - GAP - CARD_HEIGHT/2, z: BANK_WIDTH/2 + GAP + EFFECT_WIDTH/2, rotation: Math.PI/2, width: EFFECT_WIDTH, height: CARD_HEIGHT, spreadAxis: 'z', cards: [] },
            // Center piles
            { id: 'bounty', type: 'pile', player: null, x: -4 - ZONE_LENGTH/6 + CARD_WIDTH/2, z: 0, rotation: 0, width: ZONE_LENGTH/3, height: CARD_HEIGHT, spreadAxis: 'x', spreadDir: -1, cards: [] },
            { id: 'draw', type: 'pile', player: null, x: 0, z: 0, rotation: 0, width: CARD_WIDTH, height: CARD_HEIGHT, spreadAxis: null, cards: [] },
            { id: 'discard', type: 'pile', player: null, x: 3, z: 0, rotation: 0, width: CARD_WIDTH, height: CARD_HEIGHT, spreadAxis: null, cards: [] },
            { id: 'extra-mark', type: 'pile', player: null, x: 6, z: 0, rotation: 0, width: CARD_WIDTH, height: CARD_HEIGHT, spreadAxis: null, cards: [] },
        ];

        // Player lookup (index 1-4)
        const players = [
            null,
            { id: 1, hand: zones[1], bank: zones[5], mark: zones[9], effect: zones[13] },
            { id: 2, hand: zones[3], bank: zones[7], mark: zones[11], effect: zones[15] },
            { id: 3, hand: zones[0], bank: zones[4], mark: zones[8], effect: zones[12] },
            { id: 4, hand: zones[2], bank: zones[6], mark: zones[10], effect: zones[14] },
        ];

        // Center pile references
        const piles = {
            bounty: zones[16],
            draw: zones[17],
            discard: zones[18],
            extraMark: zones[19],
        };

        let scene, camera, renderer, raycaster, mouse;
        let cards = [];
        let draggedCard = null;
        let dragOffset = new THREE.Vector3();
        let dragStartPos = new THREE.Vector3();
        let tablePlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        let animatingCards = [];

        // Network state
        let peer = null;
        let isHost = false;
        let roomCode = null;
        let myPlayerNumber = null;
        let myPlayerId = null; // Generated fresh per session to allow multi-tab testing
        let myPlayerName = null;

        // Host-only state
        let connections = new Map();     // peerId -> DataConnection
        let playerSlots = new Map();     // playerId -> playerNumber
        let peerToPlayer = new Map();    // peerId -> playerId
        let playerNames = new Map();     // playerId -> name

        // Client-only state
        let hostConnection = null;

        // Shared state (for labels)
        let currentPlayerList = [];

        // Flag to ignore incoming state updates briefly after local actions
        let ignoreNextStateUpdate = false;

        // Turn state (synchronized across network)
        let turnState = {
            currentPlayerNum: 1,    // Player number whose turn it is (1-4)
            actionsRemaining: 3,    // Actions left this turn (0-3)
            gameStarted: false      // Whether the game has officially started
        };

        // Message types
        const MSG = {
            JOIN_REQUEST: 'join_request',
            JOIN_ACCEPTED: 'join_accepted',
            JOIN_REJECTED: 'join_rejected',
            PLAYER_LIST: 'player_list',
            STATE_UPDATE: 'state_update',
            STATE_BROADCAST: 'state_broadcast',
        };

        // === UTILITY FUNCTIONS ===

        // Update player labels around the table
        // Player positions: 1=bottom, 2=right, 3=top, 4=left
        function updatePlayerLabels() {
            // Remove existing labels
            document.querySelectorAll('.player-label').forEach(el => el.remove());

            if (!currentPlayerList.length) return;

            const positionClasses = ['bottom', 'right', 'top', 'left'];

            for (const player of currentPlayerList) {
                // Only show labels for connected players
                if (!player.connected) continue;

                const posClass = positionClasses[player.num - 1];
                const isYou = player.num === myPlayerNumber;

                const label = document.createElement('div');
                label.className = `player-label ${posClass}${isYou ? ' you' : ''}`;
                label.textContent = player.name || `Player ${player.num}`;
                document.body.appendChild(label);
            }

            // Also update turn indicators when game is started
            if (turnState.gameStarted) {
                updateTurnUI();
            }
        }

        function updateTurnUI() {
            // Update action counter display
            let counter = document.getElementById('action-counter');
            if (!counter && turnState.gameStarted) {
                counter = document.createElement('div');
                counter.id = 'action-counter';
                document.body.appendChild(counter);
            }

            if (counter) {
                // Show X's for remaining actions
                counter.textContent = 'X'.repeat(turnState.actionsRemaining);

                // Dim if not your turn
                if (turnState.currentPlayerNum === myPlayerNumber) {
                    counter.classList.remove('not-your-turn');
                } else {
                    counter.classList.add('not-your-turn');
                }
            }

            // Update player labels to highlight current turn
            document.querySelectorAll('.player-label').forEach(label => {
                label.classList.remove('current-turn');
            });

            // Find and highlight current turn player's label
            const positionClasses = ['bottom', 'right', 'top', 'left'];
            const currentPosClass = positionClasses[turnState.currentPlayerNum - 1];
            const currentLabel = document.querySelector(`.player-label.${currentPosClass}`);
            if (currentLabel) {
                currentLabel.classList.add('current-turn');
            }
        }

        function generateRoomCode() {
            return Math.floor(100000 + Math.random() * 900000).toString();
        }

        function getOrCreatePlayerId() {
            if (!myPlayerId) {
                myPlayerId = crypto.randomUUID();
            }
            return myPlayerId;
        }

        // === TURN MANAGEMENT ===

        function isMyTurn() {
            return turnState.gameStarted &&
                   turnState.currentPlayerNum === myPlayerNumber &&
                   turnState.actionsRemaining > 0;
        }

        function canPerformAction() {
            return isMyTurn();
        }

        function getNextConnectedPlayer(currentNum) {
            // Get list of connected player numbers
            const connectedNums = currentPlayerList
                .filter(p => p.connected)
                .map(p => p.num)
                .sort((a, b) => a - b);

            if (connectedNums.length === 0) return currentNum;

            // Find next connected player after currentNum
            const currentIndex = connectedNums.indexOf(currentNum);
            const nextIndex = (currentIndex + 1) % connectedNums.length;
            return connectedNums[nextIndex];
        }

        function consumeAction() {
            if (!canPerformAction()) return false;

            turnState.actionsRemaining--;

            // Auto-pass turn when actions exhausted
            if (turnState.actionsRemaining <= 0) {
                advanceTurn();
            }

            updateTurnUI();
            return true;
        }

        function advanceTurn() {
            turnState.currentPlayerNum = getNextConnectedPlayer(turnState.currentPlayerNum);
            turnState.actionsRemaining = 3;
            updateTurnUI();
        }

        function findCardZone(card) {
            for (const zone of zones) {
                if (zone.cards.includes(card)) {
                    return zone;
                }
            }
            return null;
        }

        // === ACTION EXECUTION ===

        function executeDraw() {
            // Get top card from draw pile
            const drawPile = piles.draw;
            if (drawPile.cards.length === 0) return false;

            const topCard = drawPile.cards[drawPile.cards.length - 1];
            drawPile.cards.pop();

            // Move to current player's hand
            const myHand = players[myPlayerNumber].hand;
            myHand.cards.push(topCard);

            // Layout both zones
            layoutCardsInZone(drawPile);
            layoutCardsInZone(myHand);

            consumeAction();
            sendStateUpdate();
            return true;
        }

        function executeBank(card, sourceZone, targetZone) {
            // Move card from hand to bank
            removeCardFromZones(card);
            targetZone.cards.push(card);

            layoutCardsInZone(sourceZone);
            layoutCardsInZone(targetZone);

            consumeAction();
            sendStateUpdate();
            return true;
        }

        function executePlay(card, sourceZone) {
            // Move card from hand to discard
            removeCardFromZones(card);
            piles.discard.cards.push(card);

            layoutCardsInZone(sourceZone);
            layoutCardsInZone(piles.discard);

            consumeAction();
            sendStateUpdate();
            return true;
        }

        function isOwnZone(zone) {
            if (!zone || !myPlayerNumber) return false;
            return zone.player === myPlayerNumber;
        }

        // === GAME SETUP ===

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function setupGame() {
            // Clear all zones first
            for (const zone of zones) {
                zone.cards = [];
            }

            // Separate mark cards from main deck
            const markCards = cards.filter(c => c.userData.name.includes('mark'));
            const mainDeck = cards.filter(c => !c.userData.name.includes('mark'));

            // Shuffle mark cards
            shuffle(markCards);

            // Deal marks: one to each player's mark zone, one to extra-mark
            // Player mark zones are at indices: p1=9, p2=11, p3=8, p4=10 in zones array
            const playerMarkZones = [
                players[1].mark,  // p1-mark
                players[2].mark,  // p2-mark
                players[3].mark,  // p3-mark
                players[4].mark,  // p4-mark
            ];

            // Get connected player numbers
            const connectedNums = currentPlayerList
                .filter(p => p.connected)
                .map(p => p.num);

            // Deal marks to player zones
            for (let i = 0; i < 4; i++) {
                const markCard = markCards[i];
                const markZone = playerMarkZones[i];
                const playerNum = i + 1;
                const isConnected = connectedNums.includes(playerNum);

                // Face down for connected players, face up for disconnected
                markCard.userData.faceUp = !isConnected;
                markCard.rotation.z = isConnected ? Math.PI : 0;

                markZone.cards.push(markCard);
                layoutCardsInZone(markZone, false);
            }

            // Deal 5th mark to extra-mark zone (face down)
            const extraMarkCard = markCards[4];
            extraMarkCard.userData.faceUp = false;
            extraMarkCard.rotation.z = Math.PI;
            piles.extraMark.cards.push(extraMarkCard);
            layoutCardsInZone(piles.extraMark, false);

            // Shuffle main deck
            shuffle(mainDeck);

            // Deal 3 cards to each connected player's hand
            let deckIndex = 0;
            for (const playerNum of connectedNums) {
                const playerHand = players[playerNum].hand;
                for (let i = 0; i < 3; i++) {
                    if (deckIndex < mainDeck.length) {
                        const card = mainDeck[deckIndex];
                        card.userData.faceUp = true;
                        card.rotation.z = 0;
                        playerHand.cards.push(card);
                        deckIndex++;
                    }
                }
                layoutCardsInZone(playerHand, false);
            }

            // Put remaining cards in draw pile, face down
            for (let i = deckIndex; i < mainDeck.length; i++) {
                const card = mainDeck[i];
                card.userData.faceUp = false;
                card.rotation.z = Math.PI;
                piles.draw.cards.push(card);
            }
            layoutCardsInZone(piles.draw, false);
        }

        // === STATE SERIALIZATION ===

        function serializeGameState() {
            const state = {
                version: 1,
                timestamp: Date.now(),
                zones: {},
                turn: {
                    currentPlayerNum: turnState.currentPlayerNum,
                    actionsRemaining: turnState.actionsRemaining,
                    gameStarted: turnState.gameStarted
                }
            };

            for (const zone of zones) {
                state.zones[zone.id] = zone.cards.map(card => ({
                    cardIndex: cards.indexOf(card),
                    faceUp: card.userData.faceUp
                }));
            }

            return state;
        }

        function applyGameState(state) {
            // Clear all zones
            for (const zone of zones) {
                zone.cards = [];
            }

            // Track cards that need flip animations
            const cardsToFlip = [];

            // Repopulate zones from state
            for (const [zoneId, cardData] of Object.entries(state.zones)) {
                const zone = zones.find(z => z.id === zoneId);
                if (!zone) continue;

                for (const { cardIndex, faceUp } of cardData) {
                    const card = cards[cardIndex];
                    if (!card) continue;

                    zone.cards.push(card);

                    // Track cards that need to flip (don't animate yet)
                    if (card.userData.faceUp !== faceUp) {
                        cardsToFlip.push({ card, faceUp });
                        card.userData.faceUp = faceUp;
                    }
                }

                // Layout cards in zone
                layoutCardsInZone(zone, true);
            }

            // NOW add flip animations (after layoutCardsInZone is done)
            for (const { card, faceUp } of cardsToFlip) {
                const targetRotZ = faceUp ? 0 : Math.PI;
                animatingCards = animatingCards.filter(a => a.card !== card);
                animatingCards.push({
                    card,
                    startPos: card.position.clone(),
                    endPos: card.position.clone(),
                    startRotZ: card.rotation.z,
                    endRotZ: targetRotZ,
                    startRot: card.rotation.y,
                    endRot: card.rotation.y,
                    liftHeight: 2,
                    baseY: card.position.y,
                    startTime: performance.now(),
                    duration: 300
                });
            }

            // Apply turn state if present
            if (state.turn) {
                turnState.currentPlayerNum = state.turn.currentPlayerNum;
                turnState.actionsRemaining = state.turn.actionsRemaining;
                turnState.gameStarted = state.turn.gameStarted;
                updateTurnUI();
            }
        }

        // === NETWORK FUNCTIONS ===

        function sendStateUpdate() {
            if (!peer) return; // Single-player or not connected

            const state = serializeGameState();

            if (isHost) {
                // Host: broadcast to all clients immediately
                // Set flag to ignore incoming state updates briefly
                ignoreNextStateUpdate = true;
                setTimeout(() => { ignoreNextStateUpdate = false; }, 100);
                broadcastState(state);
            } else if (hostConnection && hostConnection.open) {
                // Client: send to host
                // Set flag to ignore incoming broadcasts briefly (same as host)
                ignoreNextStateUpdate = true;
                setTimeout(() => { ignoreNextStateUpdate = false; }, 200);
                hostConnection.send({
                    type: MSG.STATE_UPDATE,
                    gameState: state
                });
            }
        }

        function broadcastState(state) {
            const message = {
                type: MSG.STATE_BROADCAST,
                gameState: state
            };

            for (const conn of connections.values()) {
                if (conn.open) {
                    conn.send(message);
                }
            }
        }

        function getPlayerList() {
            const list = [];
            for (let i = 1; i <= 4; i++) {
                let connected = false;
                let playerId = null;
                let name = null;

                if (i === 1 && isHost) {
                    connected = true;
                    playerId = myPlayerId;
                    name = myPlayerName;
                } else {
                    // Check if any player has this slot
                    for (const [pid, slot] of playerSlots.entries()) {
                        if (slot === i) {
                            playerId = pid;
                            name = playerNames.get(pid) || null;
                            // Check if connected
                            for (const [peerId, connPlayerId] of peerToPlayer.entries()) {
                                if (connPlayerId === pid && connections.get(peerId)?.open) {
                                    connected = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }

                list.push({ num: i, connected, name });
            }
            return list;
        }

        function broadcastPlayerList() {
            const list = getPlayerList();
            const message = { type: MSG.PLAYER_LIST, players: list };

            for (const conn of connections.values()) {
                if (conn.open) {
                    conn.send(message);
                }
            }

            // Update host's own UI
            updateLobbyPlayerList(list);
            updatePlayerLabels();
        }

        function handleIncomingConnection(conn) {
            conn.on('open', () => {
                conn.on('data', (data) => handlePeerMessage(conn, data));
                conn.on('close', () => handlePeerDisconnect(conn));
            });
        }

        function handlePeerMessage(conn, data) {
            switch (data.type) {
                case MSG.JOIN_REQUEST: {
                    const { playerId, playerName } = data;
                    console.log(`[Host] Join request from "${playerName}" (${playerId})`);

                    // Store player name
                    if (playerName) {
                        playerNames.set(playerId, playerName);
                    }

                    // Check for reconnection
                    if (playerSlots.has(playerId)) {
                        // Reconnecting player - same slot
                        const playerNum = playerSlots.get(playerId);
                        console.log(`[Host] Reconnecting player to slot ${playerNum}`);
                        acceptPlayer(conn, playerId, playerNum);
                    } else if (playerSlots.size < 4) {
                        // New player - find next slot
                        const playerNum = getNextPlayerSlot();
                        playerSlots.set(playerId, playerNum);
                        console.log(`[Host] New player assigned to slot ${playerNum}`);
                        acceptPlayer(conn, playerId, playerNum);
                    } else {
                        console.log(`[Host] Rejected - game is full`);
                        conn.send({ type: MSG.JOIN_REJECTED, reason: 'Game is full' });
                    }
                    break;
                }

                case MSG.STATE_UPDATE: {
                    // Apply state and broadcast to all (last-write-wins)
                    // Skip applying if host just made a local change
                    if (!ignoreNextStateUpdate) {
                        applyGameState(data.gameState);
                    }
                    broadcastState(data.gameState);
                    break;
                }
            }
        }

        function getNextPlayerSlot() {
            const usedSlots = new Set(playerSlots.values());
            usedSlots.add(1); // Host is always slot 1
            for (let i = 2; i <= 4; i++) {
                if (!usedSlots.has(i)) return i;
            }
            return null;
        }

        function acceptPlayer(conn, playerId, playerNum) {
            connections.set(conn.peer, conn);
            peerToPlayer.set(conn.peer, playerId);

            console.log(`[Host] Accepting player ${playerNum}, sending game state`);
            conn.send({
                type: MSG.JOIN_ACCEPTED,
                playerNumber: playerNum,
                gameState: serializeGameState(),
                playerList: getPlayerList()
            });

            console.log(`[Host] Broadcasting updated player list`);
            broadcastPlayerList();
        }

        function handlePeerDisconnect(conn) {
            const playerId = peerToPlayer.get(conn.peer);
            const playerNum = playerSlots.get(playerId);
            const playerName = playerNames.get(playerId);
            console.log(`[Host] Player disconnected: "${playerName}" (slot ${playerNum}, id: ${playerId})`);

            connections.delete(conn.peer);
            peerToPlayer.delete(conn.peer);
            // Keep playerSlots entry for reconnection

            // If disconnected player was current turn, advance to next connected player
            if (turnState.gameStarted && turnState.currentPlayerNum === playerNum) {
                // Update player list first so getNextConnectedPlayer works correctly
                currentPlayerList = getPlayerList();
                advanceTurn();
                // Broadcast the turn change with state
                broadcastState(serializeGameState());
            }

            console.log(`[Host] Broadcasting updated player list`);
            broadcastPlayerList();
        }

        function handleHostMessage(data) {
            switch (data.type) {
                case MSG.JOIN_ACCEPTED:
                    myPlayerNumber = data.playerNumber;
                    updateLobbyPlayerList(data.playerList);
                    applyGameState(data.gameState);
                    hideLobby();
                    showPlayerIndicator();
                    updatePlayerLabels();
                    break;

                case MSG.JOIN_REJECTED:
                    showLobbyError(data.reason);
                    break;

                case MSG.STATE_BROADCAST:
                    if (!ignoreNextStateUpdate) {
                        applyGameState(data.gameState);
                    }
                    break;

                case MSG.PLAYER_LIST:
                    updateLobbyPlayerList(data.players);
                    updatePlayerLabels();
                    break;
            }
        }

        // === LOBBY UI ===

        function showLobby() {
            const lobby = document.createElement('div');
            lobby.id = 'lobby';
            lobby.innerHTML = `
                <h1>Hidden Marks</h1>
                <div id="lobby-content">
                    <input type="text" id="name-input" maxlength="20" placeholder="Enter your name" style="margin-bottom: 1rem;" />
                    <div class="buttons">
                        <button id="host-btn" disabled>Host Game</button>
                        <button id="join-btn" disabled>Join Game</button>
                    </div>
                </div>
            `;
            document.body.appendChild(lobby);

            const nameInput = document.getElementById('name-input');
            const hostBtn = document.getElementById('host-btn');
            const joinBtn = document.getElementById('join-btn');

            nameInput.addEventListener('input', () => {
                const hasName = nameInput.value.trim().length > 0;
                hostBtn.disabled = !hasName;
                joinBtn.disabled = !hasName;
            });

            hostBtn.addEventListener('click', () => {
                myPlayerName = nameInput.value.trim();
                hostGame();
            });
            joinBtn.addEventListener('click', () => {
                myPlayerName = nameInput.value.trim();
                showJoinScreen();
            });

            nameInput.focus();
        }

        function showJoinScreen() {
            const content = document.getElementById('lobby-content');
            content.innerHTML = `
                <p>Enter room code:</p>
                <input type="text" id="room-input" maxlength="6" placeholder="000000" />
                <div class="buttons" style="margin-top: 1rem;">
                    <button id="connect-btn">Connect</button>
                </div>
                <button class="back-btn" id="back-btn">Back</button>
                <div id="lobby-error" class="error"></div>
            `;

            const input = document.getElementById('room-input');
            input.focus();
            input.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') joinGame(input.value);
            });

            document.getElementById('connect-btn').addEventListener('click', () => joinGame(input.value));
            document.getElementById('back-btn').addEventListener('click', () => {
                document.getElementById('lobby').remove();
                showLobby();
            });
        }

        function showHostScreen() {
            const content = document.getElementById('lobby-content');
            content.innerHTML = `
                <p>Room Code:</p>
                <div class="room-code">${roomCode}</div>
                <p>Share this code with other players</p>
                <div class="player-list" id="player-list"></div>
                <button id="start-btn" style="margin-top: 1.5rem;">Start Game</button>
            `;

            updateLobbyPlayerList(getPlayerList());

            document.getElementById('start-btn').addEventListener('click', () => {
                currentPlayerList = getPlayerList();

                // Setup game - deal marks and cards
                setupGame();

                // Initialize turn state
                turnState.gameStarted = true;
                turnState.currentPlayerNum = 1; // Host starts
                turnState.actionsRemaining = 3;

                hideLobby();
                showPlayerIndicator();
                updatePlayerLabels();
                updateTurnUI();

                // Broadcast state with turn info
                sendStateUpdate();
            });
        }

        function updateLobbyPlayerList(players) {
            currentPlayerList = players;

            const listEl = document.getElementById('player-list');
            if (!listEl) return;

            listEl.innerHTML = players.map(p => {
                const displayName = p.name || `Player ${p.num}`;
                const status = p.connected ? 'âœ“' : '...';
                return `<div class="${p.connected ? 'connected' : ''}">
                    ${displayName} ${status}
                </div>`;
            }).join('');
        }

        function showLobbyError(message) {
            const errorEl = document.getElementById('lobby-error');
            if (errorEl) errorEl.textContent = message;
        }

        function hideLobby() {
            const lobby = document.getElementById('lobby');
            if (lobby) lobby.remove();
        }

        function showPlayerIndicator() {
            const indicator = document.createElement('div');
            indicator.id = 'player-indicator';
            indicator.textContent = `You: ${myPlayerName}`;
            document.body.appendChild(indicator);
        }

        // === HOST/JOIN FLOWS ===

        async function hostGame() {
            getOrCreatePlayerId();
            roomCode = generateRoomCode();

            const content = document.getElementById('lobby-content');
            content.innerHTML = `<p>Creating room...</p>`;

            peer = new Peer(roomCode);

            peer.on('open', () => {
                isHost = true;
                myPlayerNumber = 1;
                playerSlots.set(myPlayerId, 1);
                playerNames.set(myPlayerId, myPlayerName);
                showHostScreen();
            });

            peer.on('connection', handleIncomingConnection);

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                content.innerHTML = `
                    <p class="error">Failed to create room: ${err.type}</p>
                    <button class="back-btn" id="back-btn">Back</button>
                `;
                document.getElementById('back-btn').addEventListener('click', () => {
                    document.getElementById('lobby').remove();
                    showLobby();
                });
            });
        }

        async function joinGame(code) {
            if (!code || code.length !== 6) {
                showLobbyError('Please enter a 6-digit code');
                return;
            }

            getOrCreatePlayerId();
            roomCode = code;

            const content = document.getElementById('lobby-content');
            content.innerHTML = `<p>Connecting to ${code}...</p>`;

            peer = new Peer();

            peer.on('open', () => {
                hostConnection = peer.connect(code, { reliable: true });

                hostConnection.on('open', () => {
                    hostConnection.send({
                        type: MSG.JOIN_REQUEST,
                        playerId: myPlayerId,
                        playerName: myPlayerName
                    });
                });

                hostConnection.on('data', handleHostMessage);

                hostConnection.on('close', () => {
                    // Attempt reconnection
                    setTimeout(() => {
                        if (roomCode && !document.getElementById('lobby')) {
                            showLobby();
                            showLobbyError('Disconnected from host');
                        }
                    }, 1000);
                });

                hostConnection.on('error', (err) => {
                    showLobbyError(`Connection error: ${err.type}`);
                });
            });

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    showLobbyError('Room not found');
                } else {
                    showLobbyError(`Error: ${err.type}`);
                }
                showJoinScreen();
            });
        }

        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        }

        function animateCardToZone(card, zone, targetY) {
            // Remove any existing animation for this card
            animatingCards = animatingCards.filter(a => a.card !== card);
            animatingCards.push({
                card,
                startPos: card.position.clone(),
                endPos: new THREE.Vector3(zone.x, targetY, zone.z),
                startRot: card.rotation.y,
                endRot: zone.rotation,
                startTime: performance.now(),
                duration: 300
            });
        }

        function updateAnimations() {
            const now = performance.now();
            animatingCards = animatingCards.filter(anim => {
                const elapsed = now - anim.startTime;
                const t = Math.min(elapsed / anim.duration, 1);
                const eased = easeInOut(t);

                anim.card.position.lerpVectors(anim.startPos, anim.endPos, eased);
                anim.card.rotation.y = anim.startRot + (anim.endRot - anim.startRot) * eased;

                // Handle Z rotation for flip animation with arc motion
                if (anim.startRotZ !== undefined) {
                    anim.card.rotation.z = anim.startRotZ + (anim.endRotZ - anim.startRotZ) * eased;
                    // Arc motion: lift up in middle, back down at end
                    anim.card.position.y = anim.baseY + anim.liftHeight * Math.sin(t * Math.PI);
                }

                return t < 1;
            });
        }

        function getCardPositionInZone(zone, index, total) {
            const pos = { x: zone.x, y: index * CARD_DEPTH, z: zone.z };

            if (!zone.spreadAxis || total <= 1) {
                return pos;
            }

            const maxSpread = zone.width - CARD_WIDTH;
            const spacing = Math.min(CARD_WIDTH * 0.8, maxSpread / (total - 1));
            const totalWidth = spacing * (total - 1);
            const startOffset = -totalWidth / 2;
            const offset = startOffset + index * spacing;
            const dir = zone.spreadDir || 1;

            if (zone.spreadAxis === 'x') {
                pos.x = zone.x + offset * dir;
            } else {
                pos.z = zone.z + offset * dir;
            }

            return pos;
        }

        function layoutCardsInZone(zone, animate = true) {
            const count = zone.cards.length;
            zone.cards.forEach((card, i) => {
                const pos = getCardPositionInZone(zone, i, count);
                if (animate) {
                    animatingCards = animatingCards.filter(a => a.card !== card);
                    animatingCards.push({
                        card,
                        startPos: card.position.clone(),
                        endPos: new THREE.Vector3(pos.x, pos.y, pos.z),
                        startRot: card.rotation.y,
                        endRot: zone.rotation,
                        startTime: performance.now(),
                        duration: 300
                    });
                } else {
                    card.position.set(pos.x, pos.y, pos.z);
                    card.rotation.y = zone.rotation;
                }
            });
        }

        async function init() {
            // Load sprite sheet first
            await loadSpriteSheet();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            const aspect = 1920 / 1080;
            const frustumSize = 20;
            camera = new THREE.OrthographicCamera(
                -frustumSize * aspect / 2, frustumSize * aspect / 2,
                frustumSize / 2, -frustumSize / 2,
                0.1, 100
            );
            camera.position.set(0, 20, 0);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);

            // Calculate letterboxed size
            const targetAspect = 1920 / 1080;
            const windowAspect = window.innerWidth / window.innerHeight;
            let width, height;
            if (windowAspect > targetAspect) {
                height = window.innerHeight;
                width = height * targetAspect;
            } else {
                width = window.innerWidth;
                height = width / targetAspect;
            }
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const tableGeometry = new THREE.PlaneGeometry(30, 20);
            const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.rotation.x = -Math.PI / 2;
            table.position.y = -0.01;
            scene.add(table);

            createZoneVisuals();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createDeck();
            setupEvents();
            animate();
        }

        function createZoneVisuals() {
            const zoneMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });

            for (const zone of zones) {
                const w = zone.width / 2;
                const h = zone.height / 2;
                const points = [
                    new THREE.Vector3(-w, 0, -h),
                    new THREE.Vector3(w, 0, -h),
                    new THREE.Vector3(w, 0, h),
                    new THREE.Vector3(-w, 0, h),
                    new THREE.Vector3(-w, 0, -h),
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, zoneMaterial);
                line.position.set(zone.x, 0.001, zone.z);
                line.rotation.y = zone.rotation;
                scene.add(line);
            }
        }

        let spriteSheet = null;
        let spriteCardWidth = 0;
        let spriteCardHeight = 0;

        function loadSpriteSheet() {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    spriteSheet = img;
                    spriteCardWidth = img.width / SPRITE_COLS;
                    spriteCardHeight = img.height / SPRITE_ROWS;
                    resolve();
                };
                img.src = 'spritesheet.png';
            });
        }

        const textureCache = new Map();

        function createSpriteTexture(index) {
            // Return cached texture if exists
            if (textureCache.has(index)) {
                return textureCache.get(index);
            }

            const canvas = document.createElement('canvas');
            canvas.width = spriteCardWidth;
            canvas.height = spriteCardHeight;
            const ctx = canvas.getContext('2d');

            // Calculate sprite position (1-based index)
            const i = index - 1;
            const col = i % SPRITE_COLS;
            const row = Math.floor(i / SPRITE_COLS);
            const sx = col * spriteCardWidth;
            const sy = row * spriteCardHeight;

            // Draw at native resolution - no upscaling
            ctx.drawImage(spriteSheet, sx, sy, spriteCardWidth, spriteCardHeight, 0, 0, spriteCardWidth, spriteCardHeight);

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.NoColorSpace;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            // Cache and return
            textureCache.set(index, texture);
            return texture;
        }

        function createDeck() {
            const drawPile = piles.draw;
            let cardStackIndex = 0;

            CARD_DEFS.forEach((cardDef) => {
                const copies = cardDef.count || 1;

                for (let c = 0; c < copies; c++) {
                    const faceTexture = createSpriteTexture(cardDef.index);
                    const backTexture = createSpriteTexture(cardDef.back);

                    const materials = [
                        new THREE.MeshBasicMaterial({ color: 0xffffff }),
                        new THREE.MeshBasicMaterial({ color: 0xffffff }),
                        new THREE.MeshBasicMaterial({ map: faceTexture }),
                        new THREE.MeshBasicMaterial({ map: backTexture }),
                        new THREE.MeshBasicMaterial({ color: 0xffffff }),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    ];

                    const geometry = new THREE.BoxGeometry(CARD_WIDTH, CARD_DEPTH, CARD_HEIGHT);
                    const card = new THREE.Mesh(geometry, materials);

                    card.position.set(drawPile.x, cardStackIndex * CARD_DEPTH, drawPile.z);

                    card.userData = { index: cardDef.index, name: cardDef.name, faceUp: true };
                    cards.push(card);
                    drawPile.cards.push(card);
                    scene.add(card);

                    cardStackIndex++;
                }
            });
        }

        function setupEvents() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onResize);
        }

        function updateMouse(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onMouseDown(event) {
            updateMouse(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cards);

            if (intersects.length === 0) return;

            const clickedCard = intersects[0].object;

            // Check for draw action (clicking draw pile)
            if (turnState.gameStarted && piles.draw.cards.includes(clickedCard)) {
                if (canPerformAction()) {
                    // Execute draw action - top card goes to hand
                    const topCard = piles.draw.cards[piles.draw.cards.length - 1];
                    if (clickedCard === topCard) {
                        executeDraw();
                    }
                }
                return; // Don't allow dragging from draw pile
            }

            // If game started, only allow dragging own hand cards during your turn
            if (turnState.gameStarted) {
                const myHand = players[myPlayerNumber]?.hand;
                if (!canPerformAction() || !myHand?.cards.includes(clickedCard)) {
                    return; // Can't drag if not your turn or not your hand card
                }
            }

            // Standard drag initialization
            draggedCard = clickedCard;
            dragStartPos.copy(draggedCard.position);

            const maxY = Math.max(...cards.map(c => c.position.y));
            draggedCard.position.y = maxY + CARD_DEPTH + 0.5;

            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(tablePlane, intersectPoint);
            dragOffset.copy(draggedCard.position).sub(intersectPoint);
            dragOffset.y = draggedCard.position.y;

            // Store source zone for action classification
            draggedCard.userData.sourceZone = findCardZone(draggedCard);
        }

        function onMouseMove(event) {
            if (!draggedCard) return;

            updateMouse(event);
            raycaster.setFromCamera(mouse, camera);

            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(tablePlane, intersectPoint);

            draggedCard.position.x = intersectPoint.x + dragOffset.x;
            draggedCard.position.z = intersectPoint.z + dragOffset.z;
        }

        function findNearestZone(x, z) {
            let nearest = zones[0];
            let minDist = Infinity;
            for (const zone of zones) {
                const dist = Math.hypot(x - zone.x, z - zone.z);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = zone;
                }
            }
            return nearest;
        }

        function removeCardFromZones(card) {
            for (const zone of zones) {
                const idx = zone.cards.indexOf(card);
                if (idx !== -1) {
                    zone.cards.splice(idx, 1);
                    return zone;
                }
            }
            return null;
        }

        function flipCard(card) {
            card.userData.faceUp = !card.userData.faceUp;
            const targetRotZ = card.userData.faceUp ? 0 : Math.PI;

            // Remove any existing animation for this card
            animatingCards = animatingCards.filter(a => a.card !== card);
            animatingCards.push({
                card,
                startPos: card.position.clone(),
                endPos: card.position.clone(),
                startRotZ: card.rotation.z,
                endRotZ: targetRotZ,
                startRot: card.rotation.y,
                endRot: card.rotation.y,
                liftHeight: 2,
                baseY: card.position.y,
                startTime: performance.now(),
                duration: 300
            });
        }

        function onMouseUp() {
            if (!draggedCard) return;

            // Check if it was a click (minimal movement) vs drag
            const dx = draggedCard.position.x - dragStartPos.x;
            const dz = draggedCard.position.z - dragStartPos.z;
            const distMoved = Math.sqrt(dx * dx + dz * dz);

            if (distMoved < 0.5) {
                // It's a click - flip the card
                // Return card to original position first
                draggedCard.position.x = dragStartPos.x;
                draggedCard.position.z = dragStartPos.z;
                draggedCard.position.y = dragStartPos.y;

                // Only allow flipping before game starts (free play mode)
                if (!turnState.gameStarted) {
                    flipCard(draggedCard);
                    sendStateUpdate();
                }
            } else {
                // It's a drag
                const sourceZone = draggedCard.userData.sourceZone;
                const targetZone = findNearestZone(draggedCard.position.x, draggedCard.position.z);

                if (turnState.gameStarted) {
                    // Turn-based mode: validate and execute action
                    const myHand = players[myPlayerNumber]?.hand;
                    const myBank = players[myPlayerNumber]?.bank;

                    if (sourceZone === myHand && targetZone === myBank) {
                        // Bank action: hand -> bank
                        executeBank(draggedCard, sourceZone, targetZone);
                    } else if (sourceZone === myHand && !isOwnZone(targetZone)) {
                        // Play action: hand -> outside own zones -> discard
                        executePlay(draggedCard, sourceZone);
                    } else {
                        // Invalid action - return card to original position
                        draggedCard.position.copy(dragStartPos);
                        layoutCardsInZone(sourceZone);
                    }
                } else {
                    // Free play mode (before game starts) - existing behavior
                    const oldZone = removeCardFromZones(draggedCard);
                    targetZone.cards.push(draggedCard);

                    if (oldZone && oldZone !== targetZone) {
                        layoutCardsInZone(oldZone);
                    }
                    layoutCardsInZone(targetZone);
                    sendStateUpdate();
                }
            }

            draggedCard.userData.sourceZone = null;
            draggedCard = null;
        }

        function onResize() {
            const targetAspect = 1920 / 1080;
            const windowAspect = window.innerWidth / window.innerHeight;

            let width, height;
            if (windowAspect > targetAspect) {
                // Window is wider than 16:9 - pillarbox (black bars on sides)
                height = window.innerHeight;
                width = height * targetAspect;
            } else {
                // Window is taller than 16:9 - letterbox (black bars top/bottom)
                width = window.innerWidth;
                height = width / targetAspect;
            }

            renderer.setSize(width, height);
            // Camera frustum stays fixed at 16:9
        }

        function animate() {
            requestAnimationFrame(animate);
            updateAnimations();
            renderer.render(scene, camera);
        }

        // Initialize game first, then show lobby over it
        init().then(() => showLobby());
    </script>
</body>
</html>
